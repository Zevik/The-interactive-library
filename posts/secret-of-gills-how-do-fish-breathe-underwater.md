---
title: "סוד הזימים: נשימה קסומה מתחת למים"
english_slug: secret-of-gills-how-do-fish-breathe-underwater
category: "מדעי החיים / ביולוגיה"
tags:
  - ביולוגיה
  - זימים
  - נשימה
  - פיזיולוגיה
  - אבולוציה
  - מנגנון זרימה נגדית
---
# סוד הזימים: נשימה קסומה מתחת למים

דמיינו עולם כחול ושקט, עולם שכולו מים, שבו נשימה אווירית היא בלתי אפשרית. כיצד ייתכן שחיים שלמים מתנהלים שם, עמוק מתחת לפני הים, תוך קליטת החמצן הדרוש לקיומם? הצטרפו אלינו למסע ויזואלי לגלות את הפלא הביולוגי שמאפשר לדגים וליצורים ימיים אחרים לנשום בממלכת המים - סוד הזימים!

<div id="gills-app-container" class="interactive-module">
    <h2 class="module-title">סימולציה אינטראקטיבית: מנגנון הזרימה הנגדית בזימים</h2>
    <p class="module-intro">חקרו כיצד המים והדם עוברים בזימים בכיוונים מנוגדים כדי למקסם את קליטת החמצן. צפו ברמות החמצן המשתנות לאורך הזימים והתנסו בהשפעת קצבי הזרימה השונים.</p>

    <div class="simulation-area">
        <div class="flow-container water-flow">
            <div class="flow-label">
                <span>מים נכנסים</span>
                <span class="o2-indicator high-o2">חמצן גבוה</span>
            </div>
            <div class="lamella-row-container">
                <div class="flow-arrow left-arrow"></div>
                <div class="lamella-row" id="water-segments">
                    <!-- Water segments generated by JS -->
                </div>
                <div class="flow-arrow left-arrow"></div>
            </div>
            <div class="flow-indicator-value" id="water-in-indicator"></div>
        </div>

        <div class="flow-exchange-area">
            <div class="exchange-gradient"></div> <!-- Visual hint of diffusion -->
            <div class="summary-box-row">
                 <div class="summary-box">מים נכנסים: <span id="water-in-o2">?</span></div>
                 <div class="summary-box">מים יוצאים: <span id="water-out-o2">?</span></div>
                 <div class="summary-box">דם נכנס: <span id="blood-in-o2">?</span></div>
                 <div class="summary-box">דם יוצא: <span id="blood-out-o2">?</span></div>
             </div>
        </div>

        <div class="flow-container blood-flow">
             <div class="flow-label">
                <span>דם נכנס</span>
                <span class="o2-indicator low-o2">חמצן נמוך</span>
            </div>
            <div class="lamella-row-container">
                 <div class="flow-arrow right-arrow"></div>
                 <div class="lamella-row" id="blood-segments">
                    <!-- Blood segments generated by JS -->
                 </div>
                 <div class="flow-arrow right-arrow"></div>
            </div>
             <div class="flow-indicator-value" id="blood-out-indicator"></div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="water-speed">קצב זרימת מים:</label>
            <input type="range" id="water-speed" min="10" max="200" value="100">
            <span id="water-speed-value" class="speed-value">100</span>
        </div>
        <div class="control-group">
            <label for="blood-speed">קצב זרימת דם:</label>
            <input type="range" id="blood-speed" min="10" max="200" value="100">
             <span id="blood-speed-value" class="speed-value">100</span>
        </div>
        <div class="button-group">
            <button id="start-sim" class="control-button primary">התחל סימולציה</button>
            <button id="stop-sim" class="control-button secondary" disabled>עצור סימולציה</button>
            <button id="reset-sim" class="control-button secondary">אפס</button>
        </div>
    </div>
</div>

<button id="toggle-explanation" class="explanation-toggle-button">הצג הסבר מפורט</button>

<div id="explanation-content" class="explanation-section">
    <h2>הסבר מפורט: נשימה מתחת למים באמצעות זימים</h2>

    <p>כל יצור חי זקוק לאנרגיה כדי לקיים תהליכים ביולוגיים. הפקת אנרגיה זו נעשית ברובה בתהליך הנקרא נשימה תאית, הדורש חמצן. יצורים יבשתיים מקבלים חמצן מהאוויר, אך יצורים ימיים צריכים לקלוט אותו מהמים - סביבה שבה ריכוז החמצן נמוך בהרבה (כ-1% מריכוזו באוויר), וקצב הדיפוזיה איטי יותר.</p>

    <h3>מבנה הזימים ותפקידם</h3>
    <p>זימים הם איברי הנשימה העיקריים אצל רוב בעלי החוליות הימיים (כמו דגים) ורבים מבעלי חסרי החוליות (כמו סרטנים ורכיכות). תפקידם העיקרי הוא לאפשר חילוף גזים יעיל בין זרם המים החיצוני לזרם הדם הפנימי.</p>
    <ul>
        <li><strong>שטח פנים ענק:</strong> מבנה הזימים מותאם באופן קיצוני להגדלת שטח הפנים המגע עם המים. הם מורכבים בדרך כלל מקשתות זימים, עליהן מסודרים להבונים (Filaments), ועליהם, בצפיפות רבה, מסודרות יחידות זעירות דמויות עלה הנקראות <strong>למלות (Lamellae)</strong>. המבנה המורכב הזה יוצר שטח פנים עצום שמאפשר קליטת חמצן בכמות מספקת למרות ריכוזו הנמוך במים.</li>
        <li><strong>דופן דקה:</strong> הלמלות בעלות דופן דקה במיוחד (לעיתים עובי של תא בודד), המקצרת את המרחק לדיפוזיה.</li>
        <li><strong>רשת נימי דם צפופה:</strong> כל למלה מכילה רשת צפופה של נימי דם, קרובים מאוד לפני השטח.</li>
    </ul>

    <h3>מנגנון חילוף הגזים - דיפוזיה</h3>
    <p>חילוף החמצן (וקליטת פחמן דו-חמצני, אם כי ההסבר מתמקד בחמצן) מתרחש באמצעות דיפוזיה. חמצן נע באופן ספונטני מאזור בריכוז גבוה לאזור בריכוז נמוך. כדי שחמצן יעבור מהמים לדם, ריכוז החמצן בממים במגע עם הלמלה חייב להיות גבוה יותר מריכוז החמצן בדם באותה נקודה.</p>

    <h3>עקרון הזרימה הנגדית (Countercurrent Exchange)</h3>
    <p>התאמה קריטית ויעילה במיוחד בזימים היא מנגנון הזרימה הנגדית: המים זורמים על פני הלמלות בכיוון אחד, בעוד שהדם בתוך הנימים זורם בכיוון הנגדי לחלוטין. מדוע זה כה יעיל?</p>
    <ul>
        <li><strong>שמירה על מפל ריכוזים:</strong> בזרימה נגדית, דם עני בחמצן נתקל בממים שריכוז החמצן בהם עדיין גבוה יחסית (המגיעים מהצד השני של הלמלה), ודם עשיר בחמצן נתקל בממים שריכוז החמצן בהם נמוך יחסית (הממים שעומדים לצאת מהזימים). המשמעות היא שלאורך כל אורך הלמלה, תמיד קיים מפל ריכוזים שבו ריכוז החמצן בממים גבוה מריכוזו בדם באותה נקודה.</li>
        <li><strong>מיצוי חמצן מקסימלי:</strong> בניגוד לזרימה מקבילה (בה ממים ודם זורמים באותו כיוון ושוויון בריכוזים מושג מהר), הזרימה הנגדית מאפשרת לדג למצות עד כ-80-90% מהחמצן המומס בממים שעוברים דרך הזימים. דם היוצא מהזימים יכול להגיע לריכוז חמצן גבוה משמעותית מאשר הריכוז המקסימלי האפשרי בזרימה מקבילה.</li>
    </ul>

    <p><strong>השוואה לזרימה מקבילה (Parallel Flow):</strong> אם הממים והדם היו זורמים באותו כיוון, חילוף החמצן היה מתרחש רק עד שהריכוזים בשני הזרמים היו מגיעים לשוויון בנקודה מסוימת, ואז הדיפוזיה הייתה נפסקת או נחלשת משמעותית. יעילות קליטת החמצן בזרימה מקבילה נמוכה בהרבה.</p>

    <h3>התאמות פיזיולוגיות נוספות</h3>
    <p>בנוסף למבנה ולמנגנון הזרימה, דגים משתמשים גם במנגנונים פיזיולוגיים אקטיביים: הם מזיזים את מכסה הזימים ו/או את הפה כדי ליצור זרם ממים רציף על פני הזימים (משאבת ממים). שחיינים מהירים כמו כרישים וטונה משתמשים ב"אוורור כפוי" (Ram Ventilation) - הם שוחים עם פה פתוח ומאפשרים לממים לזרום דרך הזימים באופן פסיבי יחסית.</p>

    <h3>בעלי חיים ימיים נוספים עם זימים</h3>
    <p>מנגנון הנשימה באמצעות זימים קיים בצורות שונות אצל מגוון רחב של יצורים ימיים: סרטנים, שרימפס, רכיכות (חילזונים, צדפות), כוכבי ים, תולעים ימיות, ועוד רבים. המבנה הספציפי עשוי להשתנות, אך העיקרון הבסיסי של הגדלת שטח פנים ומעבר חמצן בדיפוזיה מהממים לדם או לנוזל גוף אחר נשמר.</p>
</div>

<style>
    :root {
        --color-water-low-o2: hsl(240, 80%, 60%); /* Blue */
        --color-water-high-o2: hsl(180, 80%, 50%); /* Cyan */
        --color-blood-low-o2: hsl(0, 80%, 70%);    /* Light Red */
        --color-blood-high-o2: hsl(0, 100%, 30%);  /* Dark Red */
        --color-background-light: #eef7f6; /* Gentle teal/grey background */
        --color-card-background: #ffffff;
        --color-border-primary: #007a87; /* Teal border */
        --color-text-dark: #333;
        --color-text-light: #fff;
        --color-button-primary: #00a8b5; /* Primary Teal */
        --color-button-secondary: #e0e0e0; /* Light Grey */
        --color-button-text-primary: #fff;
        --color-button-text-secondary: #333;
        --color-summary-bg: #f0f8ff; /* Light blue for summary */
        --color-arrow: #00a8b5; /* Teal arrows */
    }

    #gills-app-container {
        font-family: 'Arial', sans-serif;
        direction: rtl;
        text-align: right;
        max-width: 850px;
        margin: 30px auto;
        padding: 25px;
        border: 1px solid var(--color-border-primary);
        border-radius: 12px;
        background-color: var(--color-background-light);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        color: var(--color-text-dark);
    }

    .module-title {
        text-align: center;
        color: var(--color-border-primary);
        margin-bottom: 10px;
        font-size: 1.8em;
        font-weight: bold;
    }

     .module-intro {
        text-align: center;
        color: #555;
        margin-bottom: 30px;
        font-size: 1em;
        line-height: 1.5;
     }

    .simulation-area {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        margin-bottom: 30px;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 10px;
        background-color: var(--color-card-background);
        box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
    }

    .flow-container {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
    }

    .flow-label {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        min-width: 120px;
        font-size: 0.9em;
        font-weight: bold;
        color: #555;
        white-space: nowrap;
        padding-left: 15px; /* Space for arrow */
    }

    .o2-indicator {
        font-size: 0.8em;
        font-weight: normal;
        padding: 2px 6px;
        border-radius: 4px;
        margin-top: 3px;
    }

    .high-o2 {
        background-color: var(--color-water-high-o2);
        color: var(--color-text-dark); /* Dark text for light background */
    }

     .low-o2 {
        background-color: var(--color-blood-low-o2);
        color: var(--color-text-dark); /* Dark text for light background */
    }


    .lamella-row-container {
        display: flex;
        align-items: center;
        flex-grow: 1;
        margin: 0 15px;
    }

    .lamella-row {
        display: flex;
        flex-grow: 1;
        height: 40px; /* Increased height for better visibility */
        border-radius: 5px;
        overflow: hidden; /* Hide segments that might overflow slightly */
         position: relative;
         box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }

    .segment {
        flex-grow: 1;
        height: 100%; /* Fill the row height */
        margin: 0; /* Remove margin between segments */
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8em;
        font-weight: bold;
        transition: background-color 0.5s ease-out; /* Smooth color transition */
        box-shadow: inset 0 0 1px rgba(0,0,0,0.1); /* Subtle separation line */
    }

    .water-segment {
         border-top: 2px solid #4dd0e1; /* Visual border */
         border-bottom: 2px solid #4dd0e1;
         color: var(--color-text-dark);
    }

     .blood-segment {
         border-top: 2px solid #ef9a9a; /* Visual border */
         border-bottom: 2px solid #ef9a9a;
         color: var(--color-text-dark);
         margin-top: 8px; /* Visual separation between flows */
    }

     .flow-arrow {
        width: 25px; /* Width of the arrow */
        height: 25px; /* Height of the arrow */
        background-color: var(--color-arrow);
        position: relative;
         flex-shrink: 0; /* Prevent shrinking */
     }

    .left-arrow {
        border-radius: 4px 0 0 4px;
        /* Pure CSS triangle for pointer */
        margin-right: -1px; /* Overlap slightly */
    }
     .left-arrow::after {
         content: '';
         position: absolute;
         right: -10px; /* Position the point */
         top: 50%;
         transform: translateY(-50%);
         width: 0;
         height: 0;
         border-top: 12.5px solid transparent;
         border-bottom: 12.5px solid transparent;
         border-left: 10px solid var(--color-arrow);
     }


    .right-arrow {
        border-radius: 0 4px 4px 0;
        /* Pure CSS triangle for pointer */
         margin-left: -1px; /* Overlap slightly */
    }
     .right-arrow::after {
         content: '';
         position: absolute;
         left: -10px; /* Position the point */
         top: 50%;
         transform: translateY(-50%);
         width: 0;
         height: 0;
         border-top: 12.5px solid transparent;
         border-bottom: 12.5px solid transparent;
         border-right: 10px solid var(--color-arrow);
     }


    .flow-indicator-value {
         font-size: 1em;
         font-weight: bold;
         color: var(--color-border-primary);
         min-width: 60px;
         text-align: left; /* Align % values to the left */
         padding-left: 10px;
    }


    .flow-exchange-area {
        position: relative;
        margin: 20px 0;
        text-align: center;
    }

    .exchange-gradient {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        height: 20px;
        background: linear-gradient(to right, var(--color-water-high-o2), #fff, var(--color-blood-high-o2)); /* Hint of exchange */
        opacity: 0.2;
        border-radius: 10px;
        z-index: 1; /* Behind summary boxes */
    }


    .summary-box-row {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
        padding: 10px 0;
        border-top: 1px dashed #ccc;
        border-bottom: 1px dashed #ccc;
        z-index: 2; /* Above gradient */
        position: relative;
    }

    .summary-box {
        text-align: center;
        font-size: 1.1em;
        font-weight: bold;
        color: #555;
        background-color: var(--color-summary-bg);
        padding: 8px 15px;
        border-radius: 6px;
        border: 1px solid #b3e5fc;
        min-width: 150px; /* Ensure boxes have space */
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

     .summary-box span {
        font-weight: bold;
        color: var(--color-border-primary);
        margin-left: 5px;
    }

    .controls {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 1px solid #eee;
        text-align: center;
    }

    .control-group {
        margin-bottom: 15px;
        display: inline-block; /* Align controls */
        margin: 0 15px 15px 15px;
    }

    .controls label {
        margin-left: 10px;
        font-weight: bold;
        color: #555;
    }

    .controls input[type="range"] {
        vertical-align: middle;
        width: 180px; /* Wider slider */
        margin-left: 10px;
         -webkit-appearance: none;
         appearance: none;
         height: 8px;
         background: #ddd;
         outline: none;
         opacity: 0.8;
         transition: opacity .2s;
         border-radius: 4px;
    }

    .controls input[type="range"]:hover {
        opacity: 1;
    }

    .controls input[type="range"]::-webkit-slider-thumb {
         -webkit-appearance: none;
         appearance: none;
         width: 20px;
         height: 20px;
         background: var(--color-button-primary);
         cursor: pointer;
         border-radius: 50%;
         box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

     .controls input[type="range"]::-moz-range-thumb {
         width: 20px;
         height: 20px;
         background: var(--color-button-primary);
         cursor: pointer;
         border-radius: 50%;
         box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .speed-value {
        font-weight: bold;
        color: var(--color-border-primary);
        min-width: 30px;
        display: inline-block;
        text-align: left;
    }

    .button-group {
        margin-top: 20px;
    }

     .control-button {
        margin: 0 8px;
        padding: 10px 20px;
        font-size: 1.1em;
        cursor: pointer;
        border: none;
        border-radius: 6px;
        transition: background-color 0.3s ease, transform 0.1s ease;
        min-width: 120px;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

     .control-button.primary {
        background-color: var(--color-button-primary);
        color: var(--color-button-text-primary);
    }

    .control-button.secondary {
        background-color: var(--color-button-secondary);
        color: var(--color-button-text-secondary);
        border: 1px solid #ccc;
    }

     .control-button:hover:not(:disabled) {
        opacity: 0.9;
        transform: translateY(-1px);
        box-shadow: 0 5px 8px rgba(0,0,0,0.15);
    }
    .control-button:active:not(:disabled) {
         transform: translateY(0);
         box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .control-button:disabled {
        background-color: #cccccc;
        color: #666;
        cursor: not-allowed;
        box-shadow: none;
    }

    .explanation-toggle-button {
        display: block;
        width: fit-content;
        margin: 30px auto 20px auto;
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        border: 1px solid var(--color-border-primary);
        border-radius: 6px;
        background-color: transparent;
        color: var(--color-border-primary);
        transition: background-color 0.3s ease, color 0.3s ease;
        font-weight: bold;
    }

    .explanation-toggle-button:hover {
        background-color: var(--color-border-primary);
        color: var(--color-button-text-primary);
    }

    .explanation-section {
        margin-top: 20px;
        padding: 25px;
        border: 1px solid #ddd;
        border-radius: 10px;
        background-color: var(--color-card-background);
        display: none; /* Hidden by default */
        direction: rtl;
        text-align: right;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    }

    .explanation-section h2, .explanation-section h3 {
        color: var(--color-border-primary);
        border-bottom: 1px solid #eee;
        padding-bottom: 8px;
        margin-top: 20px;
        margin-bottom: 15px;
    }
     .explanation-section h2 {
        font-size: 1.6em;
     }
     .explanation-section h3 {
        font-size: 1.3em;
     }


    .explanation-section p {
        line-height: 1.7;
        margin-bottom: 15px;
        color: #444;
    }
    .explanation-section ul {
        margin-bottom: 15px;
        padding-right: 25px;
        line-height: 1.6;
        color: #444;
    }
    .explanation-section li {
        margin-bottom: 8px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .simulation-area {
            padding: 15px;
        }
        .flow-container {
            flex-direction: column;
            align-items: center;
        }
        .flow-label {
             min-width: auto;
             margin-bottom: 10px;
             padding-left: 0;
             align-items: center;
        }
        .lamella-row-container {
             width: 100%;
             margin: 0;
        }
         .flow-arrow {
            display: none; /* Hide arrows on small screens */
         }
         .lamella-row {
             margin: 0;
         }
        .flow-indicator-value {
            text-align: center;
            margin-top: 10px;
            padding-left: 0;
        }
        .summary-box-row {
            flex-direction: column;
            align-items: center;
        }
        .summary-box {
            margin-bottom: 10px;
            width: 90%;
            max-width: 300px;
        }
         .control-group {
            display: block;
            margin: 0 auto 15px auto;
            text-align: left; /* Align label+slider */
            width: fit-content;
         }
         .controls input[type="range"] {
             width: calc(100% - 100px); /* Adjust width for label */
             min-width: 150px;
         }
          .button-group {
             display: flex;
             flex-wrap: wrap;
             justify-content: center;
          }
          .control-button {
             flex-grow: 1;
             margin: 5px;
          }
           .explanation-section {
             padding: 15px;
           }
            .explanation-section ul {
                padding-right: 15px;
            }
    }

</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const waterSegmentsContainer = document.getElementById('water-segments');
        const bloodSegmentsContainer = document.getElementById('blood-segments');
        const numSegments = 15; // Increased segments for smoother visual flow

        // Generate segments dynamically
        function createSegments(container, type, initialO2) {
            container.innerHTML = ''; // Clear existing
            for (let i = 0; i < numSegments; i++) {
                const segment = document.createElement('div');
                segment.classList.add('segment', `${type}-segment`);
                segment.dataset.o2 = initialO2;
                container.appendChild(segment);
            }
            return Array.from(container.children);
        }

        let waterSegments = createSegments(waterSegmentsContainer, 'water', 100);
        let bloodSegments = createSegments(bloodSegmentsContainer, 'blood', 10);


        const waterSpeedInput = document.getElementById('water-speed');
        const bloodSpeedInput = document.getElementById('blood-speed');
        const waterSpeedValueSpan = document.getElementById('water-speed-value');
        const bloodSpeedValueSpan = document.getElementById('blood-speed-value');
        const startButton = document.getElementById('start-sim');
        const stopButton = document.getElementById('stop-sim');
        const resetButton = document.getElementById('reset-sim');
        const toggleExplanationButton = document.getElementById('toggle-explanation');
        const explanationContent = document.getElementById('explanation-content');

        const waterInO2Span = document.getElementById('water-in-o2');
        const waterOutO2Span = document.getElementById('water-out-o2');
        const bloodInO2Span = document.getElementById('blood-in-o2');
        const bloodOutO2Span = document.getElementById('blood-out-o2');

        const waterInIndicator = document.getElementById('water-in-indicator');
        const bloodOutIndicator = document.getElementById('blood-out-indicator');


        let simulationInterval = null;
        const initialWaterO2 = 100; // Scale is relative, not absolute percentage
        const initialBloodO2 = 10;
        const diffusionRate = 0.08; // Controls how much O2 transfers per step

        // Adjusted Color function for better visual distinction
        function getO2Color(o2, type) {
             const clampedO2 = Math.max(0, Math.min(100, o2));
             let hue, saturation, lightness;

             if (type === 'water') {
                 // Gradient from Blue (low O2) to Cyan (high O2)
                 hue = 240 - (clampedO2 / 100) * 60; // 240 (blue) to 180 (cyan)
                 saturation = 80;
                 lightness = 60 - (clampedO2 / 100) * 10; // Slightly darker at higher O2
             } else { // blood
                 // Gradient from Light Red (low O2) to Dark Red (high O2)
                 hue = 0; // Red
                 saturation = 80 + (clampedO2 / 100) * 20; // More saturated at high O2
                 lightness = 70 - (clampedO2 / 100) * 40; // Darker at high O2
             }
             return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }


        function updateSegmentVisuals(segment, o2, type) {
            segment.style.backgroundColor = getO2Color(o2, type);
            // Adjust text color based on lightness for contrast
            segment.style.color = (o2 > 60 && type === 'water') || (o2 < 40 && type === 'blood') ? 'var(--color-text-dark)' : 'var(--color-text-light)';
            segment.textContent = Math.round(o2); // Show rounded number
        }

        function initializeSimulation() {
            // Re-create segments to reset DOM state completely
             waterSegments = createSegments(waterSegmentsContainer, 'water', initialWaterO2);
             bloodSegments = createSegments(bloodSegmentsContainer, 'blood', initialBloodO2);

            // Set initial oxygen levels and colors
            waterSegments.forEach(segment => updateSegmentVisuals(segment, parseFloat(segment.dataset.o2), 'water'));
            bloodSegments.forEach(segment => updateSegmentVisuals(segment, parseFloat(segment.dataset.o2), 'blood'));

            // Update summary and indicators
            waterInO2Span.textContent = Math.round(initialWaterO2) + '%';
            bloodInO2Span.textContent = Math.round(initialBloodO2) + '%';
            waterOutO2Span.textContent = '?%';
            bloodOutO2Span.textContent = '?%';
            waterInIndicator.textContent = Math.round(initialWaterO2) + '%';
            bloodOutIndicator.textContent = Math.round(initialBloodO2) + '%';


            // Reset button states
            startButton.disabled = false;
            stopButton.disabled = true;
            resetButton.disabled = false;

             // Reset slider values and display
            waterSpeedInput.value = 100;
            bloodSpeedInput.value = 100;
            waterSpeedValueSpan.textContent = 100;
            bloodSpeedValueSpan.textContent = 100;
        }

        function runSimulationStep() {
            const waterFlowRate = parseInt(waterSpeedInput.value) / 100; // Scale 10-200 to 0.1-2
            const bloodFlowRate = parseInt(bloodSpeedInput.value) / 100;

            // Use more iterations for smoother 'flow' and faster simulation at higher speeds
            // The number of segment shifts per step is based on speed
            const waterShifts = Math.max(1, Math.round(waterFlowRate * (numSegments / 10))); // E.g., speed 100 (rate 1) means 1.5 shifts
            const bloodShifts = Math.max(1, Math.round(bloodFlowRate * (numSegments / 10)));


             // Perform diffusion/exchange for the current state before flow
             for (let i = 0; i < numSegments; i++) {
                let waterO2 = parseFloat(waterSegments[i].dataset.o2);
                let bloodO2 = parseFloat(bloodSegments[i].dataset.o2);

                // Diffusion proportional to difference and a constant rate
                const transfer = (waterO2 - bloodO2) * diffusionRate;

                 waterSegments[i].dataset.o2 = waterO2 - transfer;
                 bloodSegments[i].dataset.o2 = bloodO2 + transfer;

                 // Clamp values
                waterSegments[i].dataset.o2 = Math.max(0, Math.min(100, parseFloat(waterSegments[i].dataset.o2)));
                bloodSegments[i].dataset.o2 = Math.max(0, Math.min(100, parseFloat(bloodSegments[i].dataset.o2)));
            }


            // Perform flow (Countercurrent: Water L->R, Blood R->L)
            // Create temporary arrays for the 'next' state after flow
            const nextWaterO2s = new Array(numSegments);
            const nextBloodO2s = new Array(numSegments);

             // Shift water segments based on waterShifts
             for(let s = 0; s < waterShifts; s++) {
                 // Shift array contents right
                 const lastO2 = parseFloat(waterSegments[numSegments - 1].dataset.o2); // Keep track of the last segment's O2 before shifting
                 for (let i = numSegments - 1; i > 0; i--) {
                     nextWaterO2s[i] = parseFloat(waterSegments[i-1].dataset.o2);
                 }
                 nextWaterO2s[0] = initialWaterO2; // New water enters the first segment

                 // Update segments based on the shift for the next diffusion step
                 for (let i = 0; i < numSegments; i++) {
                     waterSegments[i].dataset.o2 = nextWaterO2s[i];
                 }
                 // Update visuals after each segment shift within the step for smoother animation illusion
                 waterSegments.forEach((segment) => updateSegmentVisuals(segment, parseFloat(segment.dataset.o2), 'water'));
             }


             // Shift blood segments based on bloodShifts
             for(let s = 0; s < bloodShifts; s++) {
                // Shift array contents left
                 const firstO2 = parseFloat(bloodSegments[0].dataset.o2); // Keep track of the first segment's O2 before shifting
                 for (let i = 0; i < numSegments - 1; i++) {
                     nextBloodO2s[i] = parseFloat(bloodSegments[i+1].dataset.o2);
                 }
                 nextBloodO2s[numSegments-1] = initialBloodO2; // New blood enters the last segment

                 // Update segments based on the shift
                 for (let i = 0; i < numSegments; i++) {
                     bloodSegments[i].dataset.o2 = nextBloodO2s[i];
                 }
                 // Update visuals after each segment shift
                bloodSegments.forEach((segment) => updateSegmentVisuals(segment, parseFloat(segment.dataset.o2), 'blood'));
             }


            // Update visuals for the *final* state after all shifts and diffusion
             waterSegments.forEach((segment) => updateSegmentVisuals(segment, parseFloat(segment.dataset.o2), 'water'));
             bloodSegments.forEach((segment) => updateSegmentVisuals(segment, parseFloat(segment.dataset.o2), 'blood'));


            // Update summary values
            waterOutO2Span.textContent = Math.round(parseFloat(waterSegments[numSegments - 1].dataset.o2)) + '%';
            bloodOutO2Span.textContent = Math.round(parseFloat(bloodSegments[0].dataset.o2)) + '%';
             waterInIndicator.textContent = Math.round(initialWaterO2) + '%'; // Stays constant
             bloodOutIndicator.textContent = Math.round(parseFloat(bloodSegments[0].dataset.o2)) + '%'; // Updated
        }

        function startSimulation() {
            if (simulationInterval) clearInterval(simulationInterval);
            // Interval speed controls how *often* runSimulationStep is called.
            // The *speed* sliders control how many *internal shifts* happen per call.
            // This provides a smoother visual flow effect for higher speeds.
            simulationInterval = setInterval(runSimulationStep, 80); // Reduced interval for smoother animation

            startButton.disabled = true;
            stopButton.disabled = false;
        }

        function stopSimulation() {
            clearInterval(simulationInterval);
            simulationInterval = null;
            startButton.disabled = false;
            stopButton.disabled = true;
        }

        function resetSimulation() {
            stopSimulation();
            initializeSimulation();
        }

        // Event Listeners
        startButton.addEventListener('click', startSimulation);
        stopButton.addEventListener('click', stopSimulation);
        resetButton.addEventListener('click', resetSimulation);

        waterSpeedInput.addEventListener('input', (e) => {
             waterSpeedValueSpan.textContent = e.target.value;
             // Simulation logic uses this value directly in runSimulationStep
        });
         bloodSpeedInput.addEventListener('input', (e) => {
            bloodSpeedValueSpan.textContent = e.target.value;
             // Simulation logic uses this value directly in runSimulationStep
        });

        toggleExplanationButton.addEventListener('click', () => {
            const isHidden = explanationContent.style.display === 'none' || explanationContent.style.display === '';
            explanationContent.style.display = isHidden ? 'block' : 'none';
            toggleExplanationButton.textContent = isHidden ? 'הסתר הסבר מפורט' : 'הצג הסבר מפורט';
        });

        // Initial setup
        initializeSimulation();
        waterSpeedValueSpan.textContent = waterSpeedInput.value; // Ensure initial display matches input
        bloodSpeedValueSpan.textContent = bloodSpeedInput.value;

         // Hide explanation initially (CSS also helps, but JS controls state)
        explanationContent.style.display = 'none';
        // Ensure the button text is correct on load
        toggleExplanationButton.textContent = 'הצג הסבר מפורט';
    });
</script>
```