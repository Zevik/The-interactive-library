---
title: "כשקרקע בולעת: מסע אינטראקטיבי לבטן האדמה לחקר בולענים"
english_slug: when-ground-swallows-simulating-sinkhole-formation
category: "מדעי הסביבה / כדור הארץ"
tags: [בולענים, קרסט, גיאולוגיה, מי תהום, המסה, סימולציה]
---

# כשקרקע בולעת: מסע אינטראקטיבי לבטן האדמה

דמיינו: אתם עומדים על קרקע יציבה, ופתאום - היא קורסת תחת רגליכם! בולענים (Sinkholes) הם תופעה דרמטית של הטבע, שבה האדמה נשמטת לפתע ויוצרת בור ענק. אבל מה מתרחש שם, עמוק בפנים, מתחת לפני השטח, שגורם לקריסה כה פתאומית? בואו נצלול יחד להבין את הכוחות הנסתרים הפועלים מתחת לאדמה.

<div class="simulation-container">
    <h2>הדמיית היווצרות בולען</h2>
    <div class="controls">
        <div class="control-group">
            <label for="water-table">מפלס מי התהום:</label>
            <input type="range" id="water-table" min="0" max="10" value="3">
            <span id="water-table-value"></span>
        </div>
        <div class="control-group">
            <label for="precipitation">כמות ו"חומציות" מים:</label>
            <input type="range" id="precipitation" min="0" max="10" value="5">
            <span id="precipitation-value"></span>
        </div>
        <div class="control-group">
            <label for="rock-type">סוג הסלע התת-קרקעי:</label>
            <select id="rock-type">
                <option value="low">עמיד במיוחד (גרניט, בזלת)</option>
                <option value="medium">בינוני (אבן חול, צפחה)</option>
                <option value="high">מסיס (אבן גיר, גבס, מלח)</option>
            </select>
            <span id="rock-type-value"></span>
        </div>
        <div class="control-group button-group">
            <button id="start-sim">התחל הדמיה</button>
            <button id="reset-sim">איפוס</button>
        </div>
    </div>
    <div class="simulation-area">
        <div class="ground-surface">פני השטח היציבים</div>
        <div class="subsurface" id="subsurface-grid">
            <!-- Grid cells will be generated by JS -->
        </div>
        <div class="water-table-line" id="water-table-line"></div>
         <div class="simulation-overlay" id="simulation-overlay">
             <div class="overlay-text" id="overlay-text"></div>
         </div>
    </div>
     <div class="sim-status" id="sim-status">מצב: מוכן להתחלה</div>
</div>

<button id="toggle-explanation" class="toggle-button">רוצים לדעת עוד? לחצו כאן להסבר המלא</button>

<div id="explanation" style="display: none;">
    <h2>הסבר מדעי: מדוע הקרקע בולעת? תופעת הבולענים</h2>
    <p>בולענים (Sinkholes) הם למעשה תוצאה של תהליכים גיאולוגיים איטיים החלים מתחת לפני השטח, לרוב באזורים המכונים נוף קרסטי. הם נוצרים כאשר שכבות קרקע או סלע עליונות קורסות לתוך חללים תת-קרקעיים שכבר נוצרו.</p>

    <h3>השחקנים הראשיים: סלעים מסיסים ומים</h3>
    <p>התנאי ההכרחי להיווצרות בולען הוא קיום סלע תת-קרקעי הניתן להמסה על ידי מים. הסלעים הנפוצים ביותר שגורמים לתופעה הם סלעי משקע כימיים כמו אבן גיר (Calcium Carbonate - CaCO3), גבס (Calcium Sulfate - CaSO4), ומלח (Sodium Chloride - NaCl). סלעים אלו מגיבים כימית עם מים ומסיסים בהם, אם כי בקצבים שונים.</p>

    <h3>תפקידם המרכזי של המים</h3>
    <p>מים הם סוכני ההמסה. מי גשמים, בזמן חלחולם דרך האטמוספרה והקרקע העליונה, סופחים פחמן דו-חמצני (CO2). מגע זה יוצר חומצה פחמתית חלשה (H2CO3). כשמים מעט חומציים אלו מגיעים לשכבת הסלע המסיס, הם מתחילים "לאכול" אותו לאט ובהתמדה.</p>

    <h3>מסע המים ויצירת החללים</h3>
    <p>המים המחלחלים מוצאים את דרכם לרוב דרך סדקים, שברים ונקבוביות קיימים בסלע. לאורך נתיבי זרימה אלו, תהליך ההמסה מתרחש באופן מוגבר. הסדקים מתרחבים, חללים קטנים מתחילים להיווצר. עם חלוף הזמן (שיכול להיות מאות, אלפי ואף עשרות אלפי שנים), החללים הקטנים גדלים, מתחברים זה לזה ויוצרים מערכת מורכבת של מערות, מעברים תת-קרקעיים או "כיסים" גדולים בתוך מסת הסלע – אלו הם החללים התת-קרקעיים.</p>

    <h3>מנגנון הקריסה הדרמטי</h3>
    <p>ככל שהחלל התת-קרקעי מתרחב, השכבות המונחות מעליו – סלע נוסף, שכבות קרקע, ולעיתים גם מבנים מעשה ידי אדם – נתמכות על "גג" החלל. אם הגג עשוי מסלע חזק ועמיד, הוא יכול להחזיק את המשקל שמעליו למשך זמן רב. אולם, שני דברים עיקריים עלולים להוביל לקריסה:
    <ol>
        <li>**המשך ההמסה:** המים ממשיכים לכרסם בסלע הגג, מחלישים אותו בהדרגה.</li>
        <li>**עומס גובר או אובדן תמיכה:** כאשר המשקל המונח על גג החלל הופך כבד מדי, או כאשר תמיכה כלשהי מוסרת (למשל, ירידה משמעותית במפלס מי התהום, שבעבר מילאו חלקית את החלל וסיפקו תמיכה הידרוסטטית), הגג עלול להפוך בלתי יציב.</li>
    </ol>
    ברגע שחוזק הגג אינו מספיק לשאת את העומס שמעליו, הוא קורס פנימה בפתאומיות. קריסה זו גורמת לשמיטת הקרקע או הסלע מעל החלל, וליצירת השקע או הבור האופייני – הבולען – הנראה על פני השטח.</p>

    <h3>גורמים אנושיים וטבעיים מזרזים</h3>
    <p>פעולות מסוימות ושינויים סביבתיים יכולים להאיץ את התהליך או לזרז קריסה:
    <ul>
        <li>**שינויים במפלס מי התהום:** שאיבת יתר מפחיתה תמיכה, ואילו עלייה פתאומית יכולה להגביר לחצים.</li>
        <li>**פיתוח ובנייה:** משקל מבנים, כבישים או מאגרי מים מוסיף עומס על הקרקע.</li>
        <li>**שינויי אקלים:** אירועי גשם קיצוניים מגבירים חלחול וקצב המסה.</li>
        <li>**דליפות מים מצנרת:** מים מואצים יכולים להגביר המסה או לשאת חומר דק אל החללים.</li>
    </ul>
    </p>
    <p>ההדמיה מציגה מודל פשטני של תהליכים מורכבים אלו, ומאפשרת לחקור כיצד שילוב של סוג סלע, כמות מים ומפלס מי תהום משפיעים על קצב היווצרות החללים והסבירות לקריסה.</p>
</div>

<style>
    /* General Styles */
    body {
        font-family: 'Arial', sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        padding: 20px;
    }

    h1, h2, h3 {
        color: #0056b3;
        margin-bottom: 15px;
    }

    p {
        margin-bottom: 10px;
    }

    /* Simulation Container */
    .simulation-container {
        border: 1px solid #b0c4de; /* Light steel blue */
        padding: 20px;
        margin: 30px auto; /* Center the container */
        background-color: #ffffff;
        border-radius: 12px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        max-width: 800px; /* Limit container width */
        overflow: hidden; /* Ensure nothing spills out */
    }

    .simulation-container h2 {
         text-align: center;
         color: #0056b3;
         margin-top: 0;
         margin-bottom: 20px;
    }

    /* Controls */
    .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 25px;
        padding-bottom: 20px;
        border-bottom: 1px solid #e0e0e0;
        justify-content: center;
    }

    .control-group {
        display: flex;
        flex-direction: column;
        min-width: 180px;
        flex: 1 1 180px; /* Allow flexing */
    }

    .control-group label {
        margin-bottom: 8px;
        font-weight: bold;
        color: #555;
        font-size: 0.95em;
    }

    .control-group input[type="range"],
    .control-group select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #f9f9f9;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        font-size: 1em;
    }

     .control-group input[type="range"] {
         -webkit-appearance: none;
         appearance: none;
         height: 8px;
         background: #ddd;
         outline: none;
         opacity: 0.8;
         transition: opacity .2s;
         border-radius: 4px;
     }
     .control-group input[type="range"]:hover {
         opacity: 1;
     }
     .control-group input[type="range"]::-webkit-slider-thumb {
         -webkit-appearance: none;
         appearance: none;
         width: 20px;
         height: 20px;
         background: #007bff;
         cursor: pointer;
         border-radius: 50%;
         border: 2px solid #fff;
         box-shadow: 0 1px 3px rgba(0,0,0,0.2);
     }
     .control-group input[type="range"]::-moz-range-thumb {
         width: 20px;
         height: 20px;
         background: #007bff;
         cursor: pointer;
         border-radius: 50%;
         border: 2px solid #fff;
         box-shadow: 0 1px 3px rgba(0,0,0,0.2);
     }

     .control-group span {
         display: block;
         margin-top: 5px;
         font-size: 0.85em;
         color: #666;
         text-align: center;
     }

    .button-group {
        flex-direction: row; /* Arrange buttons side-by-side */
        align-items: flex-end; /* Align buttons to the bottom of the group */
        gap: 10px; /* Space between buttons */
        flex-basis: 100%; /* Take full width on smaller screens */
        justify-content: center; /* Center buttons */
    }


     .control-group button {
        padding: 10px 15px;
        background-color: #007bff; /* Primary blue */
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.3s ease, transform 0.1s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
     }

    .control-group button:hover {
        background-color: #0056b3; /* Darker blue on hover */
    }
     .control-group button:active {
         transform: scale(0.98); /* Subtle press effect */
     }
     .control-group button:disabled {
         background-color: #ccc;
         cursor: not-allowed;
     }


    /* Simulation Area */
    .simulation-area {
        position: relative;
        width: 100%;
        height: 350px; /* Adjusted height for better view */
        border: 2px solid #a0522d; /* Sienna color for Earth boundary */
        overflow: hidden;
        background: linear-gradient(to bottom, #e0f2f7 0%, #b3e5fc 50%, #81d4fa 100%); /* Sky gradient */
        display: flex;
        flex-direction: column;
        border-radius: 8px;
    }

     .simulation-overlay {
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background-color: rgba(255, 255, 255, 0.7); /* Semi-transparent white */
         display: flex;
         justify-content: center;
         align-items: center;
         z-index: 10;
         pointer-events: none; /* Allow clicks/interactions "through" the overlay */
         opacity: 0; /* Initially hidden */
         transition: opacity 0.5s ease;
     }

     .simulation-overlay.active {
         opacity: 1;
     }

     .overlay-text {
         font-size: 1.5em;
         font-weight: bold;
         color: #d32f2f; /* Red color for warnings/results */
         text-align: center;
         text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
     }


    .ground-surface {
        height: 25px; /* Slightly thicker soil layer */
        background-color: #8b4513; /* Saddle brown - Soil color */
        color: white;
        text-align: center;
        line-height: 25px;
        font-size: 0.9em;
        position: relative;
        z-index: 5; /* Above subsurface */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Subtle shadow */
         transition: height 0.8s ease-out, background-color 0.8s ease-out, box-shadow 0.8s ease-out; /* Smoother collapse transition */
         border-bottom: none; /* No border initially */
    }

    .ground-surface.collapsed {
         height: 5px; /* Collapsed height */
         background-color: #5a2c0a; /* Darker soil */
         /* border-bottom: 20px solid #333; /* Visual sinkhole lip - or use pseudo elements */
         box-shadow: none; /* No shadow when collapsed */
    }

     /* Pseudo-element for the visual sinkhole rim */
     .ground-surface.collapsed::after {
         content: '';
         display: block;
         position: absolute;
         left: 50%; /* Center the hole */
         bottom: -20px; /* Position below the collapsed surface */
         transform: translateX(-50%); /* Center horizontally */
         width: 80%; /* Width of the hole relative to container */
         max-width: 150px; /* Max width of the hole */
         height: 20px; /* Height of the 'lip' */
         background-color: #333; /* Dark color for the void/lip */
         border-radius: 50% 50% 0 0; /* Rounded top edge */
         z-index: 4; /* Below ground surface, above cavity */
     }


    .subsurface {
        flex-grow: 1;
        display: grid;
        gap: 0px; /* No gap between cells for a solid look */
        background-color: #ccc; /* Base grid background - shouldn't be visible with 0 gap */
        position: relative;
        z-index: 1;
        /* Background gradient below the grid cells to suggest depth/lower layers */
         background: linear-gradient(to bottom, #f0f0f0 0%, #d0d0d0 50%, #a0a0a0 100%);
         overflow: hidden; /* Hide cells that might move/transition out */
    }

    .grid-cell {
        background-color: #a0a0a0; /* Default rock color */
        box-sizing: border-box;
        transition: background-color 0.5s ease, opacity 0.5s ease, transform 0.5s ease; /* Smooth transitions */
        border: 1px solid rgba(0,0,0,0.05); /* Subtle cell borders */
    }

    /* Rock Type Colors */
    .cell-rock-low { background-color: #a0a0a0; } /* Durable rock (Grey) */
    .cell-rock-medium { background-color: #b08968; } /* Medium rock (Brownish) */
    .cell-rock-high { background-color: #d4bbaa; } /* Soluble rock (Light brown/beige - like limestone) */

    /* Water/Wetness Visual */
    /* This class will be added temporarily to wet cells */
    .cell-wet {
         /* This is hard to do with just background-color. A simpler approach is to darken/change color */
         /* We'll handle water coloring in JS updateGridVisuals by mixing color */
    }

    /* Dissolving Visual */
     .cell-dissolving {
         /* This state is managed by JS applying a color based on dissolution % */
     }


    /* Cavity Visual */
    .cell-cavity {
        background-color: rgba(255, 255, 255, 0.8); /* Light, almost transparent to show void */
        border: 1px dashed #777; /* Dashed border for void */
         box-shadow: inset 0 0 5px rgba(0,0,0,0.2); /* Inner shadow to suggest depth */
    }

     /* State when a cell has collapsed (under the sinkhole) */
     .cell-collapsed {
         background-color: #555 !important; /* Dark void color */
         border-color: #333 !important;
         opacity: 0; /* Start fading out */
         transform: translateY(20px); /* Start dropping */
     }
     .cell-cavity.under-sinkhole {
         background-color: #333; /* Darker cavity color where exposed by sinkhole */
         border-color: #111;
         box-shadow: none;
     }


    .water-table-line {
        position: absolute;
        left: 0;
        width: 100%;
        border-top: 2px dashed rgba(0, 0, 200, 0.6); /* Semi-transparent blue dashed line */
        z-index: 4; /* Below ground surface, above subsurface */
        transition: bottom 0.8s ease; /* Smoother movement */
    }

    /* Explanation Toggle Button */
    .toggle-button {
        display: block;
        margin: 25px auto;
        padding: 12px 25px;
        background-color: #28a745; /* Success green */
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1.1em;
        transition: background-color 0.3s ease, transform 0.1s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .toggle-button:hover {
        background-color: #218838; /* Darker green on hover */
    }
     .toggle-button:active {
         transform: scale(0.98);
     }


    /* Explanation Area */
    #explanation {
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #b0c4de;
        background-color: #fefefe;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }

    #explanation h2, #explanation h3 {
        color: #0056b3;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
        margin-bottom: 10px;
    }

    #explanation ul, #explanation ol {
        margin-left: 20px;
        margin-bottom: 10px;
    }
     #explanation li {
         margin-bottom: 8px;
     }

     /* Status display */
     .sim-status {
         text-align: center;
         margin-top: 15px;
         font-size: 0.9em;
         color: #555;
     }

</style>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const subsurfaceGrid = document.getElementById('subsurface-grid');
        const waterTableSlider = document.getElementById('water-table');
        const precipitationSlider = document.getElementById('precipitation');
        const rockTypeSelect = document.getElementById('rock-type');
        const startSimButton = document.getElementById('start-sim');
        const resetSimButton = document.getElementById('reset-sim');
        const explanationDiv = document.getElementById('explanation');
        const toggleExplanationButton = document.getElementById('toggle-explanation');
        const waterTableValueSpan = document.getElementById('water-table-value');
        const precipitationValueSpan = document.getElementById('precipitation-value');
        const rockTypeValueSpan = document.getElementById('rock-type-value');
        const waterTableLine = document.getElementById('water-table-line');
        const groundSurface = document.querySelector('.ground-surface');
        const simulationOverlay = document.getElementById('simulation-overlay');
        const overlayText = document.getElementById('overlay-text');
        const simStatus = document.getElementById('sim-status');


        // Simulation Parameters & State
        const GRID_WIDTH = 40; // Wider grid
        const GRID_HEIGHT = 20; // Taller grid
        const SOIL_DEPTH = 3; // Top layers are soil (increased)
        let grid = [];
        let simulationInterval = null;
        let simulationRunning = false;
        let simStep = 0;
        const MAX_SIM_STEPS = 600; // Allow more steps

        // Config based on controls
        let waterTableDepth_gridRow = GRID_HEIGHT - parseInt(waterTableSlider.value); // Row index (0 is top)
        let waterAcidity = parseFloat(precipitationSlider.value) * 0.05 + 0.02; // 0.02 to 0.52 (minimum acidity always)
        let rockSolubilityRates = { low: 0.005, medium: 0.02, high: 0.08 }; // Slower rates
        let rockStabilityThresholds = { low: 150, medium: 80, high: 30 }; // Higher thresholds

        let currentRockSolubility = rockSolubilityRates[rockTypeSelect.value];
        let currentRockStability = rockStabilityThresholds[rockTypeSelect.value];


        // Initialize Grid
        function initializeGrid() {
            stopSimulation(); // Stop any running simulation
            grid = [];
            subsurfaceGrid.innerHTML = ''; // Clear previous grid
            subsurfaceGrid.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, 1fr)`;
            subsurfaceGrid.style.gridTemplateRows = `repeat(${GRID_HEIGHT}, 1fr)`;

            const selectedRockType = rockTypeSelect.value;
            currentRockSolubility = rockSolubilityRates[selectedRockType];
            currentRockStability = rockStabilityThresholds[selectedRockType];

            for (let y = 0; y < GRID_HEIGHT; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = {
                        type: y < SOIL_DEPTH ? 'soil' : 'rock',
                        rockType: selectedRockType, // Store specific rock type
                        dissolution: 0, // How much dissolved
                        stability: currentRockStability, // How much dissolution needed to fail (for rock)
                        hasWater: false,
                        isCavity: false,
                        isCollapsed: false, // For collapse animation
                        element: document.createElement('div')
                    };
                    cell.element.classList.add('grid-cell');
                     if (cell.type === 'rock') {
                         cell.element.classList.add(`cell-rock-${selectedRockType}`);
                     } else {
                          cell.element.style.backgroundColor = '#8b4513'; // Soil color
                     }
                    subsurfaceGrid.appendChild(cell.element);
                    grid[y][x] = cell;
                }
            }
            updateWaterTableVisual();
            groundSurface.classList.remove('collapsed');
             // Reset soil cells visibility/state
             for(let y=0; y<SOIL_DEPTH; y++) {
                  for(let x=0; x<GRID_WIDTH; x++) {
                       const cell = grid[y][x];
                       cell.isCollapsed = false;
                       cell.element.style.visibility = 'visible';
                       cell.element.style.opacity = 1;
                       cell.element.style.transform = 'translateY(0)';
                       cell.element.style.backgroundColor = '#8b4513'; // Ensure soil color reset
                       cell.element.className = 'grid-cell'; // Reset classes
                       cell.element.classList.add('cell-soil'); // Add a soil class for potential styling
                  }
             }

            groundSurface.style.height = '25px'; // Reset ground visual
            simulationOverlay.classList.remove('active');
            overlayText.textContent = '';
            simStep = 0;
             simStatus.textContent = 'מצב: מוכן להתחלה';
            startSimButton.textContent = 'התחל הדמיה';
            startSimButton.disabled = false;
        }

        // Update Water Table Visual
        function updateWaterTableVisual() {
             const subsurfaceHeight = subsurfaceGrid.clientHeight;
             const cellHeight = subsurfaceHeight / GRID_HEIGHT;
             // Position from bottom of subsurface grid
             // waterTableDepth_gridRow is the row index (0-based from top)
             const waterLineBottom = (GRID_HEIGHT - waterTableDepth_gridRow) * cellHeight; // Position from bottom
             waterTableLine.style.bottom = `${waterLineBottom}px`;
        }


        // Simulation Logic
        function simulateStep() {
            if (simStep >= MAX_SIM_STEPS) {
                 stopSimulation();
                 showOverlay("ההדמיה הסתיימה (מקסימום צעדים)");
                 simStatus.textContent = 'מצב: הסתיימה';
                 startSimButton.disabled = true;
                 return;
            }

            // 1. Water Distribution (simplification)
            // Cells below water table always have water. Cells above can get water from 'rain' or flow.
            let wetCellsThisStep = new Set(); // Track cells that become wet this step

            // Start with cells below water table and cavities
            for(let y=0; y<GRID_HEIGHT; y++) {
                 for(let x=0; x<GRID_WIDTH; x++) {
                     grid[y][x].hasWater = false; // Reset water status
                     if (y >= waterTableDepth_gridRow || grid[y][x].isCavity) {
                          grid[y][x].hasWater = true;
                          wetCellsThisStep.add(`${x},${y}`);
                     }
                 }
            }

             // Simulate "rain" entering through the top soil/rock layer above water table
             if (waterAcidity > 0.05) {
                  const rainSpots = Math.floor(waterAcidity * GRID_WIDTH * 0.5); // More spots with higher acidity
                  for (let i = 0; i < rainSpots; i++) {
                      const x = Math.floor(Math.random() * GRID_WIDTH);
                       const y = SOIL_DEPTH; // Water enters the top rock layer
                       if (y < waterTableDepth_gridRow && grid[y] && grid[y][x] && grid[y][x].type === 'rock' && !grid[y][x].isCavity) {
                           grid[y][x].hasWater = true;
                           wetCellsThisStep.add(`${x},${y}`);
                       }
                  }
             }


            // 2. Water Flow (Simple spreading to neighbors)
            // Water spreads from newly wet cells to adjacent (non-cavity) cells above water table
            let spreadOccurred = true;
            let iterationCount = 0;
            const maxIterations = 10; // Prevent infinite loops

            while (spreadOccurred && iterationCount < maxIterations) {
                spreadOccurred = false;
                const cellsToProcess = new Set(wetCellsThisStep); // Process only cells that became wet in this/previous iteration
                wetCellsThisStep.clear(); // Prepare for next iteration's newly wet cells

                cellsToProcess.forEach(cellKey => {
                    const [x, y] = cellKey.split(',').map(Number);
                    if (grid[y][x].hasWater) { // Check if the cell is actually wet (could have been processed already)
                         // Check neighbors (up, down, left, right, diagonals)
                        for(let dy = -1; dy <= 1; dy++) {
                            for(let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const ny = y + dy;
                                const nx = x + dx;

                                // Check bounds, not soil, not already wet, not cavity, and above water table
                                if (ny >= SOIL_DEPTH && ny < GRID_HEIGHT && nx >= 0 && nx < GRID_WIDTH) {
                                     const neighbor = grid[ny][nx];
                                     if (neighbor.type === 'rock' && !neighbor.hasWater && !neighbor.isCavity && ny < waterTableDepth_gridRow) {
                                          neighbor.hasWater = true;
                                          spreadOccurred = true;
                                          wetCellsThisStep.add(`${nx},${ny}`); // Add to next iteration's processing list
                                     }
                                }
                            }
                        }
                    }
                });
                iterationCount++;
            }


            // 3. Dissolution
            // Rock cells with water and *above* the permanent water table dissolve based on acidity and rock type
            for (let y = SOIL_DEPTH; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    // Dissolution only happens in rock cells that have water AND are above the stable water table
                    // This simulates flow/variable saturation causing dissolution, not just being submerged permanently
                    if (cell.type === 'rock' && cell.hasWater && !cell.isCavity && y < waterTableDepth_gridRow) {
                        cell.dissolution += waterAcidity * currentRockSolubility;
                         // Cap dissolution progress for visual mapping, but allow exceeding threshold internally
                         // cell.dissolution = Math.min(cell.dissolution, cell.stability * 1.5); // Allow exceeding for threshold trigger
                    }
                }
            }

            // 4. Cavity Formation
            // If dissolution exceeds stability, cell becomes a cavity
            for (let y = SOIL_DEPTH; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    if (cell.type === 'rock' && !cell.isCavity && cell.dissolution >= cell.stability) {
                        cell.isCavity = true;
                         // Cavities below water table are water-filled, above are air-filled (no water)
                        cell.hasWater = (y >= waterTableDepth_gridRow);
                         // console.log(`Cavity formed at ${x}, ${y}`);
                    }
                }
            }

            // 5. Collapse Check
            // Check if a significant cavity exists directly below the soil layer
            let potentialCollapseZone = null; // { x: center, width: ?, depth: ? }

             // Scan the top few layers of rock directly below the soil
             const scanDepth = Math.min(GRID_HEIGHT - SOIL_DEPTH -1, 7); // Scan up to 7 layers below soil
             const minCavityWidthForCollapse = Math.max(5, Math.floor(GRID_WIDTH * 0.1)); // Min width 10% of grid, or 5 cells
             const minConnectedCells = minCavityWidthForCollapse * 3; // Need a contiguous area of ~3 layers * min_width

             for (let y = SOIL_DEPTH; y < SOIL_DEPTH + scanDepth; y++) {
                  let rowCavityCount = 0;
                  let firstCavityCol = -1;
                  let lastCavityCol = -1;

                  for (let x = 0; x < GRID_WIDTH; x++) {
                      if (grid[y][x].isCavity) {
                          rowCavityCount++;
                          if (firstCavityCol === -1) firstCavityCol = x;
                          lastCavityCol = x;
                      }
                  }

                  // If a row has a wide enough continuous (or near continuous) cavity zone
                  if (rowCavityCount >= minCavityWidthForCollapse && (lastCavityCol - firstCavityCol + 1) <= (rowCavityCount + 3) ) { // Check for reasonable contiguity
                       // Check the layers directly above this row for a similar cavity zone
                       let supportBelowSoil = 0;
                       for(let dy = 1; dy <= (y - SOIL_DEPTH); dy++) {
                            for(let dx = firstCavityCol; dx <= lastCavityCol; dx++) {
                                if (grid[y - dy] && grid[y-dy][dx] && grid[y-dy][dx].isCavity) {
                                     supportBelowSoil++;
                                }
                            }
                       }
                        // If there's a large enough connected cavity area just below the soil
                       if (supportBelowSoil >= minConnectedCells) {
                            potentialCollapseZone = {
                                x_start: firstCavityCol,
                                x_end: lastCavityCol,
                                y_bottom: y, // Bottom-most part of the significant cavity area
                                // We collapse based on the *top* of the cavity that triggers collapse
                                y_top_trigger: y - Math.floor(supportBelowSoil / (lastCavityCol - firstCavityCol + 1)) + 1 // Estimate the top row of the connected part
                            };
                           break; // Found a zone, trigger potential collapse
                       }
                  }
             }


             if (potentialCollapseZone) {
                 console.log(`Potential collapse detected: x=${potentialCollapseZone.x_start}-${potentialCollapseZone.x_end}, y_trigger=${potentialCollapseZone.y_top_trigger}, y_bottom=${potentialCollapseZone.y_bottom}`);
                 stopSimulation();
                 triggerCollapseAnimation(potentialCollapseZone.x_start, potentialCollapseZone.x_end, potentialCollapseZone.y_top_trigger);
                 return; // Stop simulation after collapse
             }


            // 6. Update Visuals
            updateGridVisuals();

            simStatus.textContent = `מצב: פועל, צעד ${simStep}/${MAX_SIM_STEPS}`;
            simStep++;
        }

        function updateGridVisuals() {
             const rockBaseColors = {
                  low: '#a0a0a0', // Grey
                  medium: '#b08968', // Brownish
                  high: '#d4bbaa' // Light brown
             };

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    const cellElement = cell.element;

                    // Reset classes and basic styles
                    cellElement.className = 'grid-cell';
                     if(cell.type === 'soil') {
                         cellElement.style.backgroundColor = '#8b4513'; // Ensure soil color
                          cellElement.classList.add('cell-soil');
                     } else {
                         cellElement.classList.add(`cell-rock-${cell.rockType}`);
                          cellElement.style.backgroundColor = rockBaseColors[cell.rockType]; // Start with base color
                     }
                     cellElement.style.border = '1px solid rgba(0,0,0,0.05)'; // Default border
                     cellElement.style.opacity = 1;
                     cellElement.style.transform = 'translateY(0)'; // Reset collapse animation transform


                     if (cell.isCollapsed) {
                          cellElement.classList.add('cell-collapsed');
                          continue; // Don't update other states if collapsed
                     }


                    if (cell.isCavity) {
                        cellElement.classList.add('cell-cavity');
                         // Cavities below water table look different (filled)
                         if (y >= waterTableDepth_gridRow) {
                             cellElement.style.backgroundColor = 'rgba(0, 100, 255, 0.3)'; // Semi-transparent blue for water-filled cavity
                             cellElement.style.borderColor = 'rgba(0, 0, 100, 0.5)';
                         } else {
                              cellElement.style.backgroundColor = 'rgba(255, 255, 255, 0.8)'; // White/transparent for air-filled cavity
                              cellElement.style.borderColor = '#777';
                         }

                    } else if (cell.type === 'rock') {
                         // Visualize dissolution progress for rock cells
                         const dissolutionProgress = Math.min(1.0, cell.dissolution / cell.stability); // 0 to 1.0
                         if (dissolutionProgress > 0) {
                              // Mix base rock color with a lighter color (e.g., white or a pale yellow/purple for karst)
                              const baseColor = rockBaseColors[cell.rockType];
                              const dissolutionColor = '#ffe0b2'; // Pale orange/yellow tint for dissolution
                              cellElement.style.backgroundColor = mixColors(baseColor, dissolutionColor, dissolutionProgress * 0.6); // Mix up to 60%
                              cellElement.classList.add('cell-dissolving'); // Add class for potential extra styles/animations
                         }

                         // Add visual for water in rock cells *above* water table
                         if (cell.hasWater && y < waterTableDepth_gridRow) {
                              const currentColor = getComputedStyle(cellElement).backgroundColor;
                              cellElement.style.backgroundColor = mixColors(currentColor, 'rgba(0, 100, 255, 0.2)'); // Mix with light blue
                              cellElement.classList.add('cell-wet'); // Add class for potential animation (pulse?)
                              // Pulse animation for wet cells above WT
                               if (cellElement.getAnimations().length === 0) { // Prevent multiple animations
                                    cellElement.animate([
                                         { transform: 'scale(1)', opacity: 1 },
                                         { transform: 'scale(0.98)', opacity: 0.9, backgroundColor: mixColors(cellElement.style.backgroundColor, 'rgba(0, 150, 255, 0.1)') },
                                         { transform: 'scale(1)', opacity: 1 }
                                    ], {
                                         duration: 1000,
                                         iterations: Infinity,
                                         easing: 'ease-in-out'
                                    });
                               }
                         } else {
                              // Stop pulse animation if cell dries out
                                cellElement.getAnimations().forEach(anim => anim.cancel());
                         }
                    }
                }
            }
        }

         // Helper to mix two CSS colors (basic linear interpolation)
        function mixColors(color1, color2, percentage) {
             try {
                  // Parse colors (supports rgb, rgba, hex - simplified)
                  const parseColor = (c) => {
                       if (c.startsWith('rgb')) {
                            const match = c.match(/\d+(\.\d+)?/g);
                            return match ? match.map(Number) : [0,0,0,1];
                       } else if (c.startsWith('#')) {
                            const hex = c.slice(1);
                            const bigint = parseInt(hex, 16);
                            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255, 1];
                       }
                       // Default to black if parsing fails
                       return [0,0,0,1];
                  };

                  const rgb1 = parseColor(color1);
                  const rgb2 = parseColor(color2);

                  const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * percentage);
                  const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * percentage);
                  const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * percentage);
                  const a = rgb1[3] + (rgb2[3] - rgb1[3]) * percentage; // Alpha blending

                  return `rgba(${r}, ${g}, ${b}, ${a})`;

             } catch (e) {
                  console.error("Color mixing failed:", color1, color2, percentage, e);
                  return color1; // Return original if error
             }
        }


        function triggerCollapseAnimation(leftCol, rightCol, topCavityRow) {
             showOverlay("בולען נוצר!");
             simStatus.textContent = 'מצב: בולען נוצר!';

             // Make the ground surface dip down
             groundSurface.classList.add('collapsed');

             // Animate soil cells in the collapse zone falling into the void
             const collapseDuration = 1000; // milliseconds
             const fallDistance = 50; // pixels

             // Determine the columns that collapse (slightly wider than the cavity trigger)
             const collapseColsStart = Math.max(0, leftCol - Math.floor(minCavityWidthForCollapse / 4));
             const collapseColsEnd = Math.min(GRID_WIDTH - 1, rightCol + Math.floor(minCavityWidthForCollapse / 4));


             for (let y = 0; y < SOIL_DEPTH; y++) { // Iterate through soil layers
                 for (let x = collapseColsStart; x <= collapseColsEnd; x++) {
                      if (grid[y] && grid[y][x]) {
                           const cellElement = grid[y][x].element;
                            cellElement.classList.add('cell-collapsed'); // Add collapsed class for styling
                            cellElement.style.transition = `transform ${collapseDuration}ms ease-in, opacity ${collapseDuration}ms ease-in`;
                            cellElement.style.transform = `translateY(${fallDistance}px)`; // Start falling
                            cellElement.style.opacity = 0; // Fade out as it falls
                            // After falling, remove/hide it completely
                            setTimeout(() => {
                                cellElement.style.visibility = 'hidden';
                            }, collapseDuration);
                      }
                 }
             }

             // Make the cavity cells visible or distinct under the 'hole'
              for (let y = SOIL_DEPTH; y < GRID_HEIGHT; y++) {
                 for (let x = collapseColsStart; x <= collapseColsEnd; x++) {
                      if (grid[y] && grid[y][x] && grid[y][x].isCavity) {
                           // Ensure cavity cells under the collapse zone are visible
                           grid[y][x].element.style.opacity = 1;
                           grid[y][x].element.classList.add('under-sinkhole'); // Style exposed cavity differently
                      } else if (grid[y] && grid[y][x] && y < topCavityRow + (GRID_HEIGHT - SOIL_DEPTH) * 0.3 ) { // Also hide any remaining rock cells in the immediate collapse zone
                            grid[y][x].element.style.opacity = 0; // Hide rock cells that would have fallen/been removed
                             grid[y][x].element.style.transition = `opacity ${collapseDuration}ms ease-in`;
                       }
                 }
             }

        }

        function showOverlay(message) {
            overlayText.textContent = message;
            simulationOverlay.classList.add('active');
            // Automatically hide overlay after a few seconds if needed, or keep it until reset
            // setTimeout(() => { simulationOverlay.classList.remove('active'); }, 3000);
        }


        // Control Handlers
        waterTableSlider.oninput = () => {
            waterTableDepth_gridRow = GRID_HEIGHT - parseInt(waterTableSlider.value); // Map slider 0-10 to grid rows
             const levels = ["עמוק מאוד", "עמוק", "בינוני", "רדוד", "רדוד מאוד"];
             waterTableValueSpan.textContent = levels[Math.floor(parseInt(waterTableSlider.value)/2)];
             updateWaterTableVisual();
             // Update water state immediately on change (optional, makes controls more responsive)
             for(let y=0; y<GRID_HEIGHT; y++) {
                 for(let x=0; x<GRID_WIDTH; x++) {
                      grid[y][x].hasWater = (y >= waterTableDepth_gridRow || grid[y][x].isCavity);
                 }
             }
              updateGridVisuals(); // Update appearance
        };

        precipitationSlider.oninput = () => {
            waterAcidity = parseFloat(precipitationSlider.value) * 0.05 + 0.02;
             const acidityLevels = ["נמוכה מאוד", "נמוכה", "בינונית", "גבוהה", "גבוהה מאוד"];
             precipitationValueSpan.textContent = acidityLevels[Math.floor(parseFloat(precipitationSlider.value)/2)];
        };

        rockTypeSelect.onchange = () => {
            currentRockSolubility = rockSolubilityRates[rockTypeSelect.value];
            currentRockStability = rockStabilityThresholds[rockTypeSelect.value];
             rockTypeValueSpan.textContent = rockTypeSelect.options[rockTypeSelect.selectedIndex].text;
             // Resetting grid is needed for rock type change to take effect properly
             resetSimulation();
        };

        startSimButton.onclick = () => {
            if (!simulationRunning) {
                 startSimulation();
            } else {
                 stopSimulation();
            }
        };

        resetSimButton.onclick = () => {
            resetSimulation();
        };

        function startSimulation() {
             if (!simulationRunning && simStep < MAX_SIM_STEPS && !simulationOverlay.classList.contains('active')) { // Prevent starting if already running or collapsed
                 simulationRunning = true;
                 startSimButton.textContent = 'השהה הדמיה';
                 simStatus.textContent = `מצב: פועל, צעד ${simStep}/${MAX_SIM_STEPS}`;
                 // Use setInterval for fixed steps - good for simulations
                 simulationInterval = setInterval(simulateStep, 100); // Adjust speed (milliseconds per step)
             }
        }

        function stopSimulation() {
             if (simulationRunning) {
                 simulationRunning = false;
                 startSimButton.textContent = 'המשך הדמיה';
                 simStatus.textContent = `מצב: מושהה בצעד ${simStep}`;
                 clearInterval(simulationInterval);
             }
        }

        function resetSimulation() {
            stopSimulation();
            initializeGrid();
             startSimButton.textContent = 'התחל הדמיה';
             simStatus.textContent = 'מצב: מוכן להתחלה';
            console.log("Simulation reset");
        }

        // Explanation Toggle
        toggleExplanationButton.onclick = () => {
            const isHidden = explanationDiv.style.display === 'none';
            explanationDiv.style.display = isHidden ? 'block' : 'none';
            toggleExplanationButton.textContent = isHidden ? 'הסתר הסבר' : 'רוצים לדעת עוד? לחצו כאן להסבר המלא';
        };

        // Initial setup
        initializeGrid();

        // Update initial text values for sliders/select
         waterTableSlider.dispatchEvent(new Event('input')); // Trigger input event to set initial value span text
         precipitationSlider.dispatchEvent(new Event('input'));
         rockTypeSelect.dispatchEvent(new Event('change')); // Trigger change event for select
    });
</script>
```