---
title: "הולוגרפיה במוח: האם הזיכרון שלנו מפוזר כמו קרן לייזר?"
english_slug: holographic-memory-does-our-brain-work-this-way
category: "פסיכולוגיה"
tags: [זיכרון, הולוגרפיה, נוירופסיכולוגיה, מודלים של מוח, קיבולת זיכרון, מודלים מבוזרים]
---
# הזיכרון ההולוגרפי: מבט חדש על האופן בו אנו זוכרים
האם אי פעם תהיתם מה קורה במוח שלכם כשאתם זוכרים משהו? האם הזיכרונות שלכם שמורים במגירות מסודרות, או שהם מתפשטים בצורה מפתיעה? גלו מודל מרתק שמציע שהמוח שלנו פועל כמו הולוגרמה ענקית, המסוגלת לשחזר את השלם גם מחלקים פגועים.

## הדמיה אינטראקטיבית: זיכרון הולוגרפי בפעולה (מודל פשטני)
חוו בעצמכם כיצד מידע יכול להיות מקודד ומפוזר על פני 'מדיום' נרחב, ולאפשר שחזור מפתיע גם לאחר 'פגיעה' משמעותית. התנסו לפני שתקראו את ההסבר!

<div class="holographic-app">
    <div class="app-sections">
        <div class="app-section pattern-section">
            <h3><span class="step-number">1</span> צרו זיכרון (ציירו בריבוע הקטן)</h3>
            <div class="pattern-editor" id="patternEditor">
                <!-- Grid cells will be generated by JS -->
            </div>
            <p class="instruction">לחצו על תאים כדי להפעיל/לכבות פיקסלים וליצור את ה"זיכרון".</p>
            <button id="storePatternBtn" disabled>אחסן את ה"זיכרון"</button>
        </div>

        <div class="app-section medium-section">
            <h3><span class="step-number">2</span> המדיום ההולוגרפי (הרשת העצבית)</h3>
            <div class="medium-display" id="mediumDisplay">
                <!-- Grid cells will be generated by JS -->
            </div>
            <p class="instruction">ה"זיכרון" כעת מקודד ומפוזר על פני המדיום. שימו לב: לחיצה על תא בודד אינה מגלה את ה"זיכרון" המקורי!</p>
             <button id="resetMediumBtn">נקה מדיום והתחל מחדש</button>
        </div>

         <div class="app-section damage-section">
             <h3><span class="step-number">3</span> הדמיית 'פגיעה מוחית'</h3>
             <p class="instruction">
                 'פגעו' בתאי המדיום כדי לראות איך המערכת מתמודדת עם אובדן מידע:
             </p>
             <div class="damage-controls">
                 <button id="manualDamageBtn">לחצו על תאים במדיום כדי לפגוע בהם ידנית</button>
                 <span>או:</span>
                 <input type="number" id="damagePercentage" value="30" min="0" max="100" style="width: 50px;">% מהמדיום
                 <button id="randomDamageBtn" disabled>פגעו באופן אקראי</button>
             </div>
         </div>

        <div class="app-section retrieve-section">
            <h3><span class="step-number">4</span> 'שליפת' הזיכרון (גם מהמדיום הפגוע)</h3>
            <p class="instruction">
                נסו לשחזר את ה"זיכרון" המקורי מהמדיום, גם לאחר שנגרם לו "נזק".
            </p>
            <button id="retrievePatternBtn" disabled>שלוף את ה"זיכרון"</button>
            <div class="retrieved-pattern" id="retrievedPattern">
                 <!-- Grid cells will be generated by JS -->
            </div>
             <p class="result-text">
                 <span id="retrievalResult"></span>
                 שימו לב כיצד ה"זיכרון" משוחזר, גם אם לא באופן מושלם, למרות הפגיעה המקומית במדיום.
             </p>
        </div>
    </div>
     <div class="status-message" id="statusMessage">אנא ציירו תבנית בריבוע הקטן כדי להתחיל.</div>
</div>

<style>
    /* הכללים כאן קובעים את המראה של ההדמיה. הם נטענים עם קוד ה-HTML. */
    .holographic-app {
        direction: rtl;
        text-align: right;
        font-family: 'Arial', sans-serif; /* גופן נעים יותר */
        margin-top: 30px;
        padding: 25px;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
        background-color: #fefefe; /* רקע בהיר */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* צל עדין */
        display: flex; /* שימוש ב-flexbox לסידור נוח */
        flex-direction: column;
        gap: 25px;
    }

    .app-sections {
        display: grid; /* שימוש ב-grid לסידור החלקים הראשיים */
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* עמודות גמישות */
        gap: 25px;
    }

    .app-section {
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #eee;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        align-items: center; /* ממורכז אופקית */
    }

     .app-section h3 {
         color: #0056b3; /* כותרת בצבע דומיננטי */
         margin-top: 0;
         margin-bottom: 15px;
         display: flex;
         align-items: center;
         font-size: 1.3em;
     }

     .step-number {
         display: inline-block;
         background-color: #007bff; /* מספר שלב בצבע כחול */
         color: white;
         border-radius: 50%;
         width: 28px;
         height: 28px;
         text-align: center;
         line-height: 28px;
         font-size: 1em;
         margin-left: 10px; /* רווח בין המספר לכותרת */
         box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
     }

     .instruction {
         text-align: center;
         color: #555;
         font-size: 0.95em;
         margin-bottom: 15px;
     }

     .result-text {
         text-align: center;
         color: #333;
         font-size: 0.95em;
         min-height: 1.2em; /* כדי למנוע קפיצות בגובה */
     }

     .status-message {
         text-align: center;
         margin-top: 10px;
         padding: 10px;
         border-radius: 6px;
         background-color: #e9ecef;
         color: #495057;
         font-size: 0.9em;
         min-height: 1.2em;
     }


    .pattern-editor, .retrieved-pattern {
        display: grid;
        --grid-size: 8; /* Custom property for JS access */
        grid-template-columns: repeat(var(--grid-size), var(--cell-size, 25px));
        grid-template-rows: repeat(var(--grid-size), var(--cell-size, 25px));
        gap: 2px;
        border: 2px solid #cccccc; /* גבול ברור יותר */
        margin: 10px auto;
        width: fit-content;
        background-color: #f0f0f0; /* רקע בהיר לרשת */
        border-radius: 4px;
        overflow: hidden; /* כדי שהפינות המעוגלות ייראו טוב */
    }

    .medium-display {
        display: grid;
        --grid-size: 16; /* Custom property for JS access */
        grid-template-columns: repeat(var(--grid-size), var(--cell-size, 15px));
        grid-template-rows: repeat(var(--grid-size), var(--cell-size, 15px));
        gap: 1px;
        border: 2px solid #cccccc; /* גבול ברור יותר */
        margin: 10px auto;
        width: fit-content;
        background-color: #f0f0f0;
        border-radius: 4px;
        overflow: hidden;
    }

    .pattern-cell, .medium-cell, .retrieved-cell {
        width: 100%;
        height: 100%;
        background-color: #ffffff; /* Default off/empty */
        border: none; /* אין גבולות פנימיים */
        box-sizing: border-box;
        transition: background-color 0.1s ease; /* אנימציה חלקה לשינוי צבע */
    }

    .pattern-cell {
        cursor: pointer;
    }

    .pattern-cell.active {
        background-color: #000; /* פיקסל דלוק */
        box-shadow: inset 0 0 3px rgba(0,0,0,0.5); /* צל פנימי קטן */
    }

     .pattern-cell:hover:not(.active) {
         background-color: #e0e0e0; /* הדגשה במעבר עכבר */
     }

    .medium-cell {
         background-color: #e0e0e0; /* צבע ברירת מחדל של מדיום */
         cursor: pointer;
         transition: background-color 0.2s ease; /* אנימציה חלקה */
    }

     .medium-cell:hover:not(.damaged) {
         background-color: #c0c0c0; /* הדגשה במעבר עכבר */
     }

    .medium-cell.damaged {
         background-color: #ffcccc; /* הדמיית פגיעה */
         transition: background-color 0.3s ease;
    }

     .medium-cell.damaging {
          background-color: #ff6666; /* הדמיית פגיעה אקראית אנימציה */
     }

    .retrieved-cell {
        background-color: #ffffff; /* Default off */
         transition: background-color 0.5s ease; /* אנימציה לשחזור */
    }

     .retrieved-cell.active {
          /* רק כדי לסמן שהתא 'פעיל' אחרי נרמול, הצבע נקבע על ידי ה-JS */
     }

    button {
        margin: 5px auto; /* מרכוז כפתורים */
        padding: 10px 20px;
        cursor: pointer;
        border: none;
        border-radius: 5px;
        background-color: #007bff; /* כחול */
        color: white;
        font-size: 1em;
        transition: background-color 0.2s ease, opacity 0.2s ease; /* אנימציה לכפתורים */
        display: block; /* כל כפתור בשורה משלו */
    }

    button:hover:not(:disabled) {
        background-color: #0056b3; /* כחול כהה יותר במעבר עכבר */
    }

     button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
        opacity: 0.7;
    }

    .damage-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap; /* מאפשר מעבר שורה במסכים קטנים */
        gap: 10px;
    }

    .damage-controls button {
        margin: 0; /* מבטל שוליים אוטומטיים */
        display: inline-block; /* מציג כפתורים בשורה */
    }

     .damage-controls input[type="number"] {
         padding: 8px;
         border: 1px solid #ccc;
         border-radius: 4px;
         text-align: center;
         font-size: 1em;
     }


    #explanation {
        margin-top: 40px;
        padding-top: 30px;
        border-top: 1px solid #e0e0e0;
        display: none; /* מוסתר בתחילה */
        animation: fadeIn 0.5s ease forwards; /* אנימציית הופעה */
    }

     @keyframes fadeIn {
         from { opacity: 0; }
         to { opacity: 1; }
     }

    #toggleExplanationBtn {
        display: block;
        margin: 30px auto 0; /* מרכוז הכפתור */
        background-color: #28a745; /* ירוק */
        font-size: 1.1em;
    }

    #toggleExplanationBtn:hover {
         background-color: #218838; /* ירוק כהה יותר */
    }

     h2 {
         color: #333;
         margin-bottom: 20px;
         text-align: center;
         font-size: 1.8em;
     }

     h3 {
         color: #0056b3;
         margin-top: 25px;
         margin-bottom: 10px;
         font-size: 1.4em;
     }

     p {
         margin-bottom: 15px;
         line-height: 1.6;
         color: #333;
     }

     ul {
         margin-bottom: 15px;
         line-height: 1.6;
         color: #333;
         padding-right: 20px; /* מרווח לרשימה */
     }

     li {
         margin-bottom: 8px;
     }

     /* גדלי רשת משתנים מוגדרים ב-JS */
     /* .pattern-editor, .retrieved-pattern { --cell-size: 25px; } */
     /* .medium-display { --cell-size: 15px; } */

</style>

<button id="toggleExplanationBtn">הצג הסבר מורחב: הולוגרפיה והמוח</button>

<div id="explanation">
    <h2>הסבר: זיכרון הולוגרפי והקשר המרתק למוח</h2>

    <p>דמיינו לרגע את הזיכרונות שלכם. איפה הם נמצאים במוח? האם הם מאוחסנים בקופסאות קטנות, או שהם מפוזרים בצורה הרבה יותר דינמית? מודל הזיכרון ההולוגרפי מציע פרספקטיבה מסקרנת על השאלה הזו.</p>

    <h3>מהי הולוגרמה, בעצם? לא סתם תמונה תלת-ממדית!</h3>
    כולנו מכירים הולוגרמות מחיי היום-יום - אולי על כרטיס אשראי או שטר כסף. לרוב הן נתפסות כתמונות תלת-ממדיות. אבל מהותה העמוקה יותר של הולוגרמה היא *אופן אחסון המידע* שלה. תמונה רגילה (כמו זו בטלפון שלכם) מאחסנת מידע *מקומי*: כל פיקסל מכיל מידע רק על נקודה *אחת* בסצנה. חתכו חלק מהתמונה, ואיבדתם את המידע הזה לנצח. הולוגרמה, לעומת זאת, רושמת על מדיום (כמו לוח צילום מיוחד) את *תבנית ההתאבכות* שנוצרת כאשר גלי אור (בדרך כלל לייזר) המגיעים מהאובייקט "פוגשים" גל אור אחר (גל ייחוס). התבנית הזו נראית כמו אוסף אקראי של קווים ונקודות - אין לה שום דמיון ישיר לאובייקט המקורי!

    <h3>עקרון פיזור המידע המהפכני</h3>
    הקסם האמיתי של הולוגרמה טמון בכך שכל נקודה על המדיום ההולוגרפי מכילה, בצורה מקודדת ומפוזרת, מידע על *האובייקט השלם*! זה לא אחסון ממוקד, אלא פיזור רחב. דמיינו אבן שנזרקת למים: הגלים מתפשטים על פני כל הבריכה, ולא נשארים רק בנקודת הכניסה. אחסון הולוגרפי דומה לכך.

    <h3>שליפת השלם מהחלק הקטן ביותר</h3>
    כדי "לראות" את האובייקט מההולוגרמה, מאירים עליה עם גל אור מתאים. גל זה משחזר את תבנית הגלים המקורית. והנה החלק המדהים: אם תאירו רק על *חלק קטן* מההולוגרמה, עדיין תוכלו לראות תמונה של *כל* האובייקט המקורי! היא אמנם תהיה מטושטשת יותר, כאילו "ברזולוציה" נמוכה, אבל המידע על השלם עדיין שם, מפוזר.

    <h3>קרל פריברם והמוח ההולוגרפי: תיאוריה נועזת</h3>
    בשנות ה-60 וה-70, הנוירופסיכולוג קרל פריברם, בהשראת ההולוגרפיה, הציע מודל מהפכני לזיכרון. במקום לחשוב על זיכרונות כמאוחסנים באזורים ספציפיים במוח, כמו קבצים בתיקיות, הוא שיער שהם מקודדים ומפוזרים על פני רשתות עצביות נרחבות בקליפת המוח. הוא האמין שהמוח מבצע חישובים מורכבים הדומים לטרנספורמציות פורייה, שהן הליבה המתמטית של ההולוגרפיה. במודל זה, זיכרון הוא לא נקודה בודדת, אלא תבנית פעילות מפוזרת ועשירה.

    <h3>מודלים ממוקדים מול מודלים מבוזרים</h3>
    מודלים קלאסיים ורבים עכשוויים אכן מראים שאזורים שונים במוח קשורים לסוגי זיכרון שונים (למשל, היפוקמפוס לזיכרונות חדשים, אמיגדלה לזיכרונות רגשיים). פגיעות באזורים אלה אכן פוגעות בזיכרון. אולם, מודל פריברם אינו בהכרח מבטל מודלים אלה לחלוטין. הוא מציע אולי מנגנון קידוד עמוק יותר, שבו גם אם אזור "אחראי" נפגע, המידע עדיין קיים בצורה מפוזרת ברשת רחבה יותר, ומאפשר שחזור חלקי או פגום, כפי שראיתם בהדמיה.

    <h3>לאשלי, אקיפוטנציאליות ועדויות מהמחקר</h3>
    פריברם התבסס, בין היתר, על ניסוייו המפורסמים של קרל לאשלי בשנות ה-20. לאשלי הסיק שניתן להסיר חלקים נרחבים מקליפת המוח של חולדות מאומנות, ועדיין למצוא שהן זוכרות חלקית את המבוך, בהתאם לכמות הקורטקס שנותרה, ולא למיקום הספציפי של ההסרה. הוא קרא לזה "אקיפוטנציאליות" ופיזור ה"אנגרמה" (הזיכרון). בעוד שהרעיון של אחסון מבוזר ברשתות עצביות מקובל נרחב כיום, המודל הולוגרפי ה"טהור" של פריברם, המבוסס על טרנספורמציות פורייה, נשאר שנוי במחלוקת בקהילה המדעית בשל קושי למצוא עדויות נוירוביולוגיות ישירות לכך. עם זאת, הרעיון הבסיסי של פיזור מידע ועמידות בפני פגיעה ממשיך להשפיע על מודלים עכשוויים של רשתות עצביות.

    <h3>יתרונות מודל מבוזר (הולוגרפי-למחצה): עמידות וקיבולת</h3>
    אם הזיכרון אכן מאוחסן בצורה מבוזרת, הדבר מסביר שתי תכונות מרשימות של הזיכרון האנושי:
    <ol>
        <li> **עמידות מפני פגיעה:** כפי שההדמיה מראה, אובדן של חלק מהמדיום אינו מוחק זיכרון שלם, אלא פוגע בארגונו ובהירותו. זה תואם את העובדה שפגיעות מוחיות לרוב גורמות לקשיי שליפה, עיוות או טשטוש של זיכרונות, ולא למחיקתם המוחלטת כאילו "הקובץ" נעלם.</li>
        <li> **קיבולת עצומה:** הולוגרפיה מאפשרת אחסון כמות עצומה של מידע באותו מדיום (באמצעות שימוש בזוויות שונות של גלי ייחוס). אם המוח משתמש במנגנון דומה, זה יכול להסביר את הקיבולת הכמעט בלתי מוגבלת לכאורה של הזיכרון האנושי, שבו כל נוירון וסינפסה יכולים כנראה להשתתף בקידוד זיכרונות רבים בו זמנית.</li>
    </ol>

    <p>לסיכום, מודל הזיכרון ההולוגרפי של פריברם, על אף שאינו הקונצנזוס המדעי המוחלט כיום, הוא רעיון מרתק ששינה את האופן בו חוקרים חושבים על זיכרון. הוא מדגיש את החשיבות של רשתות עצביות רחבות ופיזור מידע כבסיס לעמידות וליכולות המדהימות של הזיכרון האנושי.</p>

</div>


<script>
    /* קוד ה-JavaScript כאן מפעיל את האינטראקציה ואת ההדמיה. הוא רץ לאחר טעינת הדף. */
    document.addEventListener('DOMContentLoaded', () => {
        // קבלת הפניות לאלמנטים ב-HTML
        const patternEditor = document.getElementById('patternEditor');
        const mediumDisplay = document.getElementById('mediumDisplay');
        const retrievedPattern = document.getElementById('retrievedPattern');
        const storePatternBtn = document.getElementById('storePatternBtn');
        const retrievePatternBtn = document.getElementById('retrievePatternBtn');
        const randomDamageBtn = document.getElementById('randomDamageBtn');
        const manualDamageBtn = document.getElementById('manualDamageBtn'); // כפתור הפגיעה הידנית
        const resetMediumBtn = document.getElementById('resetMediumBtn'); // כפתור איפוס מדיום
        const damagePercentageInput = document.getElementById('damagePercentage');
        const explanationDiv = document.getElementById('explanation');
        const toggleExplanationBtn = document.getElementById('toggleExplanationBtn');
        const statusMessageDiv = document.getElementById('statusMessage'); // אלמנט להצגת הודעות סטטוס
        const retrievalResultSpan = document.getElementById('retrievalResult'); // אלמנט לתוצאות השחזור

        // הגדרות גודל הרשתות
        const PATTERN_SIZE = 8; // גודל רשת ה"זיכרון"
        const MEDIUM_SIZE = 16; // גודל רשת ה"מדיום" (רשת עצבית)
        const mediumCells = MEDIUM_SIZE * MEDIUM_SIZE;

        // מצב האפליקציה
        let pattern = Array(PATTERN_SIZE * PATTERN_SIZE).fill(0); // 0: כבוי, 1: דלוק
        let medium = Array(mediumCells).fill(0); // מאחסן ערכים מפוזרים (נקודות צפות)
        let isMediumDamaged = Array(mediumCells).fill(false); // עוקב ויזואלית אחרי תאים פגועים
        let isManualDamageMode = false; // דגל למצב פגיעה ידנית


        // --- פונקציות עזר ליצירת רשתות ---

        function createGrid(container, size, cellClass, isClickable, clickHandler) {
            container.innerHTML = ''; // ניקוי תוכן קיים
            // הגדרת גודל תא בהתאם לגודל הרשת
            const cellSize = (size === PATTERN_SIZE) ? '25px' : '15px';
            container.style.setProperty('--cell-size', cellSize);
            container.style.setProperty('--grid-size', size); // הגדרת גודל רשת בקסטום פרופרטי

            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.classList.add(cellClass);
                cell.dataset.index = i; // שמירת האינדקס של התא
                if (isClickable) {
                    cell.style.cursor = 'pointer';
                    cell.addEventListener('click', () => clickHandler(i));
                }
                container.appendChild(cell);
            }
        }

        // יצירת רשתות האפליקציה
        createGrid(patternEditor, PATTERN_SIZE, 'pattern-cell', true, (index) => {
            // לוגיקה לציור תבנית
            pattern[index] = 1 - pattern[index]; // החלף מצב
            patternEditor.children[index].classList.toggle('active', pattern[index] === 1);
            // אפשר כפתור אחסון רק אם יש משהו בציור
            const hasActiveCells = pattern.some(cell => cell === 1);
            storePatternBtn.disabled = !hasActiveCells;
            updateStatusMessage(hasActiveCells ? 'כעת אחסנו את ה"זיכרון" או המשיכו לצייר.' : 'אנא ציירו תבנית בריבוע הקטן כדי להתחיל.');
        });

        createGrid(mediumDisplay, MEDIUM_SIZE, 'medium-cell', true, (index) => {
             // לוגיקה לפגיעה ידנית
             if (isManualDamageMode && !isMediumDamaged[index]) {
                 damageSingleMediumCell(index);
                 updateStatusMessage('תא נפגע ידנית. המשיכו לפגוע או עברו לשלב השליפה.');
             } else if (isMediumDamaged[index]) {
                 // הציגו הודעה שהתא כבר פגוע
                 updateStatusMessage('תא זה כבר פגוע.', 'warning');
             } else {
                 // הציגו הודעה להפעיל מצב פגיעה
                 updateStatusMessage('לחצו על "לחצו על תאים במדיום כדי לפגוע בהם ידנית" כדי לאפשר פגיעה ידנית.', 'info');
             }
        });

        createGrid(retrievedPattern, PATTERN_SIZE, 'retrieved-cell', false);


        // --- פונקציות לוגיקה הולוגרפית (הדמיה פשטנית) ---

        // פונקציית עזר לחישוב מרחק בריבוע
        function getDistanceSq(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return dx * dx + dy * dy;
        }

         // פונקציה לעדכון הודעת סטטוס
         function updateStatusMessage(message, type = 'info') {
             statusMessageDiv.textContent = message;
             statusMessageDiv.className = `status-message status-${type}`; // הוספת קלאס לפי סוג ההודעה
         }

         // פונקציה לאיפוס המדיום ומצב הנזק
         function resetMedium() {
             medium.fill(0);
             isMediumDamaged.fill(false);
             updateMediumDisplay();
             // גם נקה את השחזור
             const retrievedCells = retrievedPattern.children;
             for (let i = 0; i < PATTERN_SIZE * PATTERN_SIZE; i++) {
                retrievedCells[i].classList.remove('active');
                retrievedCells[i].style.backgroundColor = '#ffffff';
             }
              retrievalResultSpan.textContent = ''; // ניקוי תוצאות שחזור
             // אפשר/בטל כפתורים בהתאם
              storePatternBtn.disabled = !pattern.some(cell => cell === 1);
              randomDamageBtn.disabled = true; // אין מדיום לפגוע בו
              retrievePatternBtn.disabled = true; // אין מדיום לשלוף ממנו
             updateStatusMessage('המדיום נוקה. צרו או אחסנו תבנית חדשה.');
         }


        function storePattern() {
            // איפוס המדיום ומצב הנזק לפני האחסון
            resetMedium();

            updateStatusMessage('מקודד את ה"זיכרון" אל המדיום...');

            // הדמיית אחסון: כל נקודת "אור" בתבנית משפיעה על כל נקודות המדיום
            // זהו פישוט משמעותי של תהליך הולוגרפי אמיתי (שמשתמש בטרנספורמציית פורייה)
            // כאן אנו מדמים פיזור על בסיס מרחק יחסי
            for (let py = 0; py < PATTERN_SIZE; py++) {
                for (let px = 0; px < PATTERN_SIZE; px++) {
                    const patternIndex = py * PATTERN_SIZE + px;
                    if (pattern[patternIndex] === 1) { // אם הפיקסל דלוק בתבנית
                        for (let my = 0; my < MEDIUM_SIZE; my++) {
                            for (let mx = 0; mx < MEDIUM_SIZE; mx++) {
                                const mediumIndex = my * MEDIUM_SIZE + mx;
                                // חישוב עמדה יחסית של נקודת המדיום ביחס לרשת התבנית
                                const scaledMx = mx * PATTERN_SIZE / MEDIUM_SIZE;
                                const scaledMy = my * PATTERN_SIZE / MEDIUM_SIZE;
                                const distSq = getDistanceSq(px, py, scaledMx, scaledMy);
                                // תרומה יורדת עם המרחק (אבל לא אפס)
                                medium[mediumIndex] += 1.0 / (distSq + 1.0); // הוספת 1 במכנה למניעת חלוקה באפס וריכוך השפעת המרחק
                            }
                        }
                    }
                }
            }
            console.log("Pattern Stored.");
            updateMediumDisplay(); // רענון ויזואלי של המדיום (יציג רק מצב נזק)
            randomDamageBtn.disabled = false; // עכשיו אפשר לפגוע אקראית
            retrievePatternBtn.disabled = false; // עכשיו אפשר לשלוף
             manualDamageBtn.disabled = false; // עכשיו אפשר לפגוע ידנית
            updateStatusMessage('ה"זיכרון" אוחסן בהצלחה במדיום. עכשיו נסו לפגוע בו!');
        }

        // פונקציה לפגיעה בתא מדיום בודד
        function damageSingleMediumCell(index) {
            if (!isMediumDamaged[index]) {
                 medium[index] = 0; // מדמה פגיעה ע"י איפוס הערך בתא זה
                 isMediumDamaged[index] = true;
                 mediumDisplay.children[index].classList.add('damaged');
                  // הסרת קלאס אנימציה אם קיים
                 mediumDisplay.children[index].classList.remove('damaging');
                 console.log(`Cell ${index} damaged.`);
                  // לאחר פגיעה, אפשר לשלוף שוב (אם לא אחסנו מחדש)
                 retrievePatternBtn.disabled = false;
            }
        }


        function damageMedium(percentage) {
             if (!medium.some(val => val !== 0) && !isMediumDamaged.some(d => d)) {
                 updateStatusMessage("אנא אחסנו תבנית לפני שפוגעים במדיום!", 'error');
                 return;
             }
            // ודא שאיפוס מצב פגיעה ידנית
             isManualDamageMode = false;
             manualDamageBtn.textContent = 'לחצו על תאים במדיום כדי לפגוע בהם ידנית';


            updateStatusMessage(`פוגע אקראית ב-${percentage}% מהמדיום...`);

            const totalCells = MEDIUM_SIZE * MEDIUM_SIZE;
            const cellsToDamage = Math.min(totalCells, Math.floor(totalCells * (percentage / 100))); // ודא שלא עובר את סך התאים
            let damagedCount = 0;

            // יצירת רשימת אינדקסים וערבובם
            const indices = Array.from({ length: totalCells }, (_, i) => i);
             // ערבוב Fisher-Yates
             for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // פגיעה ב-N התאים הראשונים מהרשימה המעורבבת
            for (let i = 0; i < cellsToDamage; i++) {
                 const indexToDamage = indices[i];
                 if (!isMediumDamaged[indexToDamage]) {
                    medium[indexToDamage] = 0; // סימולציית פגיעה
                    isMediumDamaged[indexToDamage] = true;
                    damagedCount++;
                 }
            }
            console.log(`Damaged approximately ${damagedCount} cells.`);
            updateMediumDisplay(true); // עדכון ויזואלי עם אפשרות לאנימציה
             updateStatusMessage(`פגענו ב-${damagedCount} תאים במדיום. כעת נסו לשלוף את ה"זיכרון".`);
        }

         // פונקציה לעדכון ויזואלי של המדיום (בעיקר מצב נזק)
        function updateMediumDisplay(animateDamage = false) {
             const cells = mediumDisplay.children;
             for(let i = 0; i < MEDIUM_SIZE * MEDIUM_SIZE; i++) {
                 if (isMediumDamaged[i]) {
                     cells[i].classList.add('damaged');
                     // הוספת אנימציה זמנית אם נדרש
                     if (animateDamage) {
                         cells[i].classList.add('damaging');
                          // הסרת קלאס האנימציה לאחר זמן קצר
                         setTimeout(() => {
                             cells[i].classList.remove('damaging');
                         }, 300); // זמן קצר לאנימציית ההבהוב
                     }
                      cells[i].style.backgroundColor = '#ffcccc'; // הדגשת נזק
                 } else {
                     cells[i].classList.remove('damaged');
                      cells[i].classList.remove('damaging');
                      cells[i].style.backgroundColor = '#e0e0e0'; // צבע תא בריא
                 }
             }
        }


        function retrievePattern() {
            if (!medium.some(val => val !== 0) && !isMediumDamaged.some(d => d)) {
                 updateStatusMessage("אנא אחסנו תבנית במדיום לפני שאתם מנסים לשלוף!", 'error');
                 return;
            }
             if (medium.every(val => val === 0) && isMediumDamaged.every(d => d)) {
                 updateStatusMessage("המדיום פגוע כולו. לא ניתן לשחזר דבר.", 'warning');
                  const retrievedCells = retrievedPattern.children;
                 for (let i = 0; i < PATTERN_SIZE * PATTERN_SIZE; i++) {
                     retrievedCells[i].classList.remove('active');
                     retrievedCells[i].style.backgroundColor = '#ffffff';
                 }
                  retrievalResultSpan.textContent = 'שחזור נכשל לחלוטין.';
                 return;
             }

            updateStatusMessage('משחזר את ה"זיכרון" מהמדיום...');
             retrievePatternBtn.disabled = true; // בטל כפתור בזמן השחזור

            let reconstructed = Array(PATTERN_SIZE * PATTERN_SIZE).fill(0);
            let maxVal = 0;
            let activeMediumCells = 0; // ספירת תאי מדיום שאינם פגועים


            // הדמיית שליפה: כל נקודת מדיום לא פגועה תורמת לשחזור כל נקודות ה"זיכרון"
             // נסרו רק על תאי המדיום הלא פגועים
            for (let my = 0; my < MEDIUM_SIZE; my++) {
                for (let mx = 0; mx < MEDIUM_SIZE; mx++) {
                    const mediumIndex = my * MEDIUM_SIZE + mx;
                    // רק אם התא לא פגוע וערכו אינו אפס (אפשרי אם המדיום נאופס ידנית לפני אחסון)
                    if (!isMediumDamaged[mediumIndex] && medium[mediumIndex] !== 0) {
                        activeMediumCells++;
                        const mediumValue = medium[mediumIndex]; // הערך המקודד בנקודה זו

                         for (let py = 0; py < PATTERN_SIZE; py++) {
                            for (let px = 0; px < PATTERN_SIZE; px++) {
                                const patternIndex = py * PATTERN_SIZE + px;
                                // שימוש באותה פונקציית מרחק הפוכה לתרומה
                                const scaledMx = mx * PATTERN_SIZE / MEDIUM_SIZE;
                                const scaledMy = my * PATTERN_SIZE / MEDIUM_SIZE;
                                const distSq = getDistanceSq(px, py, scaledMx, scaledMy);
                                // הוספת התרומה של תא מדיום זה לשחזור פיקסל התבנית
                                reconstructed[patternIndex] += mediumValue / (distSq + 1.0);
                            }
                        }
                    }
                }
            }

            // מצא את הערך המקסימלי בשחזור לנרמול
            maxVal = Math.max(...reconstructed);
             if (maxVal === 0) { // אם אין מה לשחזר בכלל
                 updateStatusMessage("שחזור נכשל. כנראה המדיום פגוע כולו או לא אוחסן כראוי.", 'warning');
                  retrievePatternBtn.disabled = false;
                 const retrievedCells = retrievedPattern.children;
                 for (let i = 0; i < PATTERN_SIZE * PATTERN_SIZE; i++) {
                     retrievedCells[i].classList.remove('active');
                     retrievedCells[i].style.backgroundColor = '#ffffff';
                 }
                  retrievalResultSpan.textContent = 'שחזור נכשל.';
                 return;
             }


            // נרמול והחלת סף - החלק שמחליט אם פיקסל "דלוק" או "כבוי" בשחזור
            // אפשר גם להשתמש בערך המנורמל לצבע אפור
            const threshold = maxVal * 0.3; // סף פשוט (למשל, 30% מהערך המקסימלי) - ניסוי וטעייה לתוצאה ויזואלית טובה

            const retrievedCells = retrievedPattern.children;
             let correctlyRetrieved = 0;
             let originalActiveCount = pattern.filter(val => val === 1).length;


             // אנימציה: הצגת השחזור בתהליך
             let delay = 0;
             const baseDelay = 5; // מילישניות לכל תא

            for (let i = 0; i < PATTERN_SIZE * PATTERN_SIZE; i++) {
                const cell = retrievedCells[i];
                const normalizedValue = reconstructed[i] / maxVal; // ערך בין 0 ל-1

                 // קביעת צבע גוון אפור בהתאם לערך המנורמל
                 // ככל שהערך גבוה יותר, הצבע כהה יותר (קרוב לשחור, כלומר 'דלוק')
                 const intensity = Math.min(255, Math.floor(normalizedValue * 255 * 1.8)); // הגברת הניגודיות קצת
                 const colorValue = 255 - intensity; // 255 לבן (0 intensity), 0 שחור (255 intensity)
                 const color = `rgb(${colorValue}, ${colorValue}, ${colorValue})`;


                 // החלת סף כדי להחליט אם התא נחשב 'דלוק' או 'כבוי' בשחזור הסופי (עבור חישוב דיוק)
                 const isActive = reconstructed[i] > threshold;


                 // עדכון ויזואלי עם אנימציה קלה
                 setTimeout(() => {
                     cell.style.backgroundColor = color;
                     if (isActive) {
                          cell.classList.add('active');
                      } else {
                           cell.classList.remove('active');
                       }

                      // בדיקת דיוק (אחרי ההחלטה על isActive)
                      if (isActive === (pattern[i] === 1)) {
                          correctlyRetrieved++;
                      }

                       // בסוף האנימציה של התא האחרון, עדכן את הסטטוס והתוצאה
                       if (i === (PATTERN_SIZE * PATTERN_SIZE) - 1) {
                            retrievePatternBtn.disabled = false; // החזרת כפתור לפעולה
                            const totalCells = PATTERN_SIZE * PATTERN_SIZE;
                            const accuracy = (correctlyRetrieved / totalCells) * 100;
                             // ספירת כמה פיקסלים אמורים להיות דלוקים במקור
                             const originalOn = pattern.filter(val => val === 1).length;
                             // ספירת כמה פיקסלים דולקים בשחזור
                             const retrievedOn = reconstructed.filter(val => val > threshold).length;
                             // חישוב שיעור המדיום הלא פגוע
                             const undamagedPercentage = ((mediumCells - isMediumDamaged.filter(d => d).length) / mediumCells) * 100;


                             retrievalResultSpan.textContent = ` שיעור המדיום הנותר: ${undamagedPercentage.toFixed(1)}%. דיוק השחזור: ${accuracy.toFixed(1)}% (שיעור התאים ששוחזרו נכון ביחס לתבנית המקורית). `;

                            updateStatusMessage('ה"זיכרון" שוחזר בהצלחה. שימו לב לדיוק השחזור לעומת שיעור הפגיעה במדיום.', 'success');
                       }

                 }, delay);
                 // הגדלת ההשהיה עבור התא הבא ליצירת אפקט בנייה הדרגתי
                 delay += baseDelay;

            }
             console.log("Pattern Retrieved.");
        }

        // --- Event Listeners ---
        storePatternBtn.addEventListener('click', storePattern);

        // פונקציה להפעלת/כיבוי מצב פגיעה ידנית
        manualDamageBtn.addEventListener('click', () => {
             if (!medium.some(val => val !== 0) && !isMediumDamaged.some(d => d)) {
                 updateStatusMessage("אנא אחסנו תבנית לפני שפוגעים במדיום!", 'error');
                 return;
             }

            isManualDamageMode = !isManualDamageMode; // החלפת מצב

            if (isManualDamageMode) {
                manualDamageBtn.textContent = 'בטל פגיעה ידנית';
                 manualDamageBtn.style.backgroundColor = '#dc3545'; /* צבע אדום במצב פעיל */
                 updateStatusMessage('לחצו על תאים במדיום הגדול כדי לפגוע בהם.', 'info');
            } else {
                manualDamageBtn.textContent = 'לחצו על תאים במדיום כדי לפגוע בהם ידנית';
                 manualDamageBtn.style.backgroundColor = '#007bff'; /* צבע כחול במצב רגיל */
                  updateStatusMessage('בחרו כיצד לפגוע במדיום, או שלפו את ה"זיכרון".');
            }
        });


        retrievePatternBtn.addEventListener('click', retrievePattern);

        randomDamageBtn.addEventListener('click', () => {
            const percentage = parseInt(damagePercentageInput.value, 10);
            if (!isNaN(percentage) && percentage >= 0 && percentage <= 100) {
                damageMedium(percentage);
            } else {
                updateStatusMessage("אנא הזינו אחוז פגיעה תקין (0-100).", 'warning');
                damagePercentageInput.value = 30; // איפוס לערך ברירת מחדל
            }
        });

         resetMediumBtn.addEventListener('click', resetMedium);


        // Toggle explanation visibility
        toggleExplanationBtn.addEventListener('click', () => {
            const isHidden = explanationDiv.style.display === 'none' || explanationDiv.style.display === '';
            explanationDiv.style.display = isHidden ? 'block' : 'none';
            toggleExplanationBtn.textContent = isHidden ? 'הסתר הסבר מורחב' : 'הצג הסבר מורחב: הולוגרפיה והמוח';
             // גלילה עדינה לאזור ההסבר אם הוא נפתח
             if (isHidden) {
                 explanationDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
             }
        });

        // --- אתחול ראשוני ---
         // איפוס מצב האפליקציה והודעות
        pattern.fill(0);
        medium.fill(0);
        isMediumDamaged.fill(false);
        updateMediumDisplay();

        const patternCells = patternEditor.children;
         for(let i=0; i < PATTERN_SIZE * PATTERN_SIZE; i++) {
             patternCells[i].classList.remove('active');
         }

         const retrievedCells = retrievedPattern.children;
         for(let i=0; i < PATTERN_SIZE * PATTERN_SIZE; i++) {
             retrievedCells[i].classList.remove('active');
             retrievedCells[i].style.backgroundColor = '#ffffff';
         }

        storePatternBtn.disabled = true;
        randomDamageBtn.disabled = true;
        retrievePatternBtn.disabled = true;
         manualDamageBtn.disabled = true;
         retrievalResultSpan.textContent = ''; // ניקוי תוצאות שחזור

        updateStatusMessage('ברוכים הבאים להדמיית הזיכרון ההולוגרפי! אנא ציירו תבנית בריבוע הקטן כדי להתחיל.');
        console.log("Holographic Memory App Initialized. Draw a pattern!");
    });
</script>
---