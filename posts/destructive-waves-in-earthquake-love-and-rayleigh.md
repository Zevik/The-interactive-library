---
title: "גלי הרס ברעידת אדמה: המאיימים האמיתיים"
english_slug: destructive-waves-in-earthquake-love-and-rayleigh
category: "גיאולוגיה"
tags: [רעידת אדמה, גלים סייסמיים, גלי אהבה, גלי ריילי, סימולציה, גלי שטח, סייסמולוגיה]
---
<h1>גלי הרס ברעידת אדמה: המאיימים האמיתיים</h1>
<p class="intro-paragraph">האם אי פעם דמיינתם את הכוחות העצומים שפועלים עמוק בבטן האדמה? רעידת אדמה משחררת אנרגיה אדירה שמתפשטת כגלים. בעוד שגלי P ו-S הראשוניים הם סימן האזהרה, דווקא "גלי השטח" המאוחרים יותר – גלי אהבה וריילי – הם המאיימים האמיתיים שגורמים את עיקר ההרס לעיירות ולערים. בואו נראה כיצד הם רוקדים את ריקוד ההרס שלהם ממש מתחת לרגלינו.</p>

<div id="simulation-area">
    <div id="sky"></div>
    <div id="ground">
        <div class="building"></div>
        <div class="building"></div>
        <div class="building"></div>
        <div class="building"></div>
        <div class="building"></div>
        <div class="building"></div>
        <div class="building"></div>
    </div>
    <div id="hypocenter"></div>
     <div id="epicenter-projection"></div>
    <button id="trigger-earthquake" class="action-button">הפעל רעידת אדמה!</button>
    <div id="waves-info" class="info-box"></div>
</div>

<button id="toggle-explanation" class="toggle-button">הצג הסבר מעמיק</button>

<div id="explanation" style="display: none;">
    <h2>הסבר מעמיק: ריקוד הגלים ההרסני</h2>
    <p>רעידת אדמה היא אירוע דרמטי המתרחש כאשר סלעים בקרום כדור הארץ נשברים וזזים לאורך העתק. האנרגיה המשתחררת נעה החוצה מהמוקד (היפוסנטר) בצורת גלים סייסמיים. נכיר את השחקנים הראשיים:</p>

    <h3>גלי גוף: המבשרים (P ו-S)</h3>
    <p>אלו הגלים הראשונים, שנעים עמוק בתוך כדור הארץ:</p>
    <ul>
        <li><strong>גלי P (גלים ראשוניים):</strong> דמיינו קפיץ שאתם דוחפים ומותחים. גלי P פועלים באותו אופן, גורמים לסלע להידחס ולהתרחב בכיוון התנועה. הם המהירים ביותר ויכולים לעבור דרך כל חומר (מוצק, נוזל, גז), ולכן הם מגיעים ראשונים.</li>
        <li><strong>גלי S (גלים שניוניים):</strong> דמיינו חבל שאתם מטלטלים מצד לצד. גלי S גורמים לחומר לזוז בניצב לכיוון התפשטות הגל (תנועת גזירה). הם איטיים יותר מגלי P ויכולים לנוע רק בתווך מוצק.</li>
    </ul>
    <p>גלי P ו-S הם לרוב פחות הרסניים בפני השטח בהשוואה לגלי השטח.</p>

    <h3>גלי שטח: המאיימים האמיתיים (אהבה וריילי)</h3>
    <p>כאשר גלי הגוף מגיעים לפני השטח, הם "מולידים" סוג חדש של גלים - גלי שטח. גלים אלו נלכדים ליד פני האדמה ומתפשטים לאורכם. הם אטיים יותר מגלי גוף אך בדרך כלל נושאים משרעת (עוצמה) גדולה יותר בפני השטח, וזו הסיבה שהם גורמים את רוב הנזק.</p>

    <ul>
        <li><strong>גלי אהבה (Love Waves):</strong> קרויים על שם המתמטיקאי אוגוסטוס אדוארד האו לַאב (Love). דמיינו שהאדמה נעה מצד לצד בתנועת "שקשוק" אופקית בלבד, בניצב לכיוון התקדמות הגל. התנועה הזו גורמת ללחצי גזירה חזקים מאוד בבסיס מבנים ומובילה לקריסה צידית.</li>
        <li><strong>גלי ריילי (Rayleigh Waves):</strong> קרויים על שם הפיזיקאי לורד ריילי. אלו הגלים המסובכים וההרסניים ביותר. הם גורמים לחלקיקי האדמה לנוע במסלול אליפטי או מעגלי לאחור, בדומה לאופן שבו נקודה על פני מים נעה כשאדווה עוברת. תנועה זו משלבת תנועה אופקית ואנכית, גורמת לקרקע "להתגלגל" או "להתנדנד", והיא לרוב בעלת המשרעת הגבוהה ביותר והארוכה ביותר בזמן, מה שמוטט מבנים רבים.</li>
    </ul>

    <h3>סדר הגעת הגלים והשפעתם</h3>
    <p>הגלים מגיעים בדרך כלל בסדר זה: <strong>P &rarr; S &rarr; אהבה &rarr; ריילי</strong>. למרות שגלי השטח מגיעים אחרונים, העוצמה הגדולה שלהם ותנועתם המורכבת (אהבה - אופקית; ריילי - אליפטית/מתגלגלת) הופכות אותם לאחראים העיקריים על הנזק הדרמטי למבנים שרואים בחדשות.</p>

    <h3>סיכום הסימולציה</h3>
    <p>הסימולציה מדגימה בצורה חזותית את ההבדל הדרמטי בין גלי שטח לגלי גוף (שמתוארים רק כגורם ליצירת גלי השטח בסימולציה זו). היא מראה כיצד גלי אהבה גורמים לתנועה צידית חזקה וכיצד גלי ריילי גורמים לתנועה משולבת הכוללת טלטול, הרמה וסיבוב של מבנים, ומסבירה מדוע הם נחשבים למאיימים האמיתיים בעת רעידת אדמה קטלנית.</p>
</div>

<style>
    body {
        font-family: 'Arial', sans-serif;
        line-height: 1.6;
        color: #333;
        margin: 0;
        padding: 20px;
        background-color: #f8f8f8;
    }

    h1, h2, h3 {
        color: #2c3e50;
    }

    .intro-paragraph {
        font-size: 1.1em;
        margin-bottom: 25px;
        color: #555;
    }

    #simulation-area {
        width: 100%;
        max-width: 800px; /* Limit max width for better layout */
        height: 400px; /* Increased height */
        border: 1px solid #bdc3c7; /* Lighter border */
        position: relative;
        overflow: hidden;
        margin: 20px auto; /* Center the simulation */
        background: linear-gradient(to bottom, #aeeeff, #ffffff); /* Simple sky gradient */
        box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Subtle shadow */
        border-radius: 8px; /* Rounded corners */
    }

     #sky {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: calc(100% - 80px); /* Sky occupies most area above ground */
        background: linear-gradient(to bottom, #87ceeb, #e0f6ff); /* More vibrant sky */
        z-index: 1;
    }

    #ground {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 80px; /* Increased ground height */
        background-color: #8b4513; /* Brown color for ground */
        background: linear-gradient(to bottom, #a0522d, #8b4513); /* Gradient for ground */
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        padding: 0 30px; /* Increased padding */
        box-sizing: border-box;
        z-index: 5; /* Ensure ground is above sky */
    }

    .building {
        width: 35px; /* Slightly wider */
        height: 100px; /* Taller buildings */
        background-color: #b0c4de; /* Grey-blue color */
        border: 1px solid #778899;
        position: relative;
        bottom: 0;
        transform-origin: bottom center;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2); /* Building shadow */
        transition: transform 0.05s linear; /* Smoother transitions */
        z-index: 6; /* Buildings above ground */
    }

    /* Optional: Add windows for more detail */
    .building::before {
        content: '';
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        bottom: 5px;
        background: repeating-linear-gradient(
            0deg,
            #e0ffff, /* Light windows */
            #e0ffff 8px, /* Window height */
            transparent 8px,
            transparent 12px /* Gap height */
        ),
        repeating-linear-gradient(
            90deg,
            #e0ffff, /* Light windows */
            #e0ffff 8px, /* Window width */
            transparent 8px,
            transparent 12px /* Gap width */
        );
         background-color: rgba(100, 149, 237, 0.3); /* Base wall color for gaps */
    }


    #hypocenter {
        position: absolute;
        width: 20px; /* Larger */
        height: 20px; /* Larger */
        background-color: #e74c3c; /* Brighter red */
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        box-shadow: 0 0 15px #e74c3c; /* Pulsing glow effect potential */
    }

    #epicenter-projection {
        position: absolute;
        width: 15px;
        height: 5px;
        background-color: rgba(231, 76, 60, 0.5); /* Semi-transparent red line */
        transform: translate(-50%, -50%);
        z-index: 8;
        bottom: 80px; /* Position it on the ground surface */
    }


    .action-button {
        position: absolute;
        bottom: 20px; /* Adjusted position */
        left: 50%;
        transform: translateX(-50%); /* Center button */
        z-index: 20;
        padding: 12px 25px; /* Larger padding */
        font-size: 1.1em;
        color: #fff;
        background-color: #3498db; /* Blue button */
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.1s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .action-button:hover {
        background-color: #2980b9;
    }
     .action-button:active {
        transform: translateX(-50%) scale(0.98);
    }

    .action-button:disabled {
        background-color: #95a5a6;
        cursor: not-allowed;
    }

    .info-box {
        position: absolute;
        top: 20px; /* Adjusted position */
        left: 50%;
        transform: translateX(-50%); /* Center info */
        z-index: 20;
        color: #2c3e50;
        font-size: 1em;
        background-color: rgba(255, 255, 255, 0.85); /* Semi-transparent white background */
        padding: 10px 15px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        min-width: 250px; /* Ensure it has some width */
        text-align: center;
    }

    .toggle-button {
        display: block; /* Make it a block element */
        margin: 20px auto; /* Center the button below simulation */
        padding: 10px 20px;
        font-size: 1em;
        color: #fff;
        background-color: #7f8c8d; /* Grey button */
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    .toggle-button:hover {
        background-color: #95a5a6;
    }

    #explanation {
        border-top: 2px solid #bdc3c7; /* Thicker border */
        margin-top: 30px; /* More space */
        padding-top: 25px;
        background-color: #ecf0f1; /* Light background for explanation */
        padding: 25px;
        border-radius: 8px;
    }
    #explanation h2, #explanation h3 {
        color: #34495e; /* Darker blue-grey */
        margin-bottom: 10px;
    }
     #explanation h3 {
         margin-top: 20px;
         font-size: 1.1em;
     }
    #explanation p {
        color: #555;
        margin-bottom: 15px;
    }
    #explanation ul {
        margin-top: 10px;
        padding-left: 20px; /* Indent list */
    }
    #explanation li {
        margin-bottom: 8px;
        color: #555;
    }
    #explanation strong {
        color: #34495e;
    }
</style>

<script>
    const simulationArea = document.getElementById('simulation-area');
    const ground = document.getElementById('ground');
    const buildings = document.querySelectorAll('.building');
    const hypocenter = document.getElementById('hypocenter');
    const epicenterProjection = document.getElementById('epicenter-projection');
    const triggerButton = document.getElementById('trigger-earthquake');
    const wavesInfo = document.getElementById('waves-info');
    const explanationDiv = document.getElementById('explanation');
    const toggleButton = document.getElementById('toggle-explanation');

    let simulationRunning = false;
    let waveTimer = 0;
    // Relative speeds - conceptual for timing surface wave effects
    // These are relative speeds *along the surface* from the epicenter projection
    const waveSpeeds = {
        // P and S waves are body waves, arriving *at the hypocenter* first,
        // then travelling up and outwards. For this surface wave focused sim,
        // we abstract their arrival at the surface epicenter projection.
        // Their "speed" here is conceptual for *when surface waves start*.
        bodyWaveReachSurfaceTime: 100, // conceptual time for body waves to reach surface projection
        Love: 2.5, // Speed of Love wave propagation along surface (pixels per frame conceptually)
        Rayleigh: 1.5 // Speed of Rayleigh wave propagation along surface (pixels per frame conceptually)
    };
    let waveEffectStartTimes = {}; // To store when surface wave *effects* start at a building location
    let waveEffectDurations = {}; // Duration of the wave effect at each building


    // Fixed Hypocenter Position (relative to simulation-area)
    // Position it 100px below the ground surface level
    const groundHeight = 80;
    const hypocenterDepth = 100;
    // Calculate Y relative to the top of the simulation area
    const groundLevelY = simulationArea.offsetHeight - groundHeight;
    const hypocenterY = groundLevelY + hypocenterDepth; // Place hypocenter *below* the visible ground

    // Center the hypocenter horizontally
    const hypocenterX = simulationArea.offsetWidth / 2;

    hypocenter.style.left = `${hypocenterX}px`;
    hypocenter.style.top = `${hypocenterY}px`;

    // Position epicenter projection directly above hypocenter, on the ground surface
     epicenterProjection.style.left = `${hypocenterX}px`;
     // epicenterProjection.style.bottom = `${groundHeight}px`; // Position from bottom
     epicenterProjection.style.top = `${groundLevelY - epicenterProjection.offsetHeight / 2}px`; // Position relative to top


    triggerButton.addEventListener('click', () => {
        if (!simulationRunning) {
            startSimulation();
        }
    });

    toggleButton.addEventListener('click', () => {
        const isHidden = explanationDiv.style.display === 'none';
        explanationDiv.style.display = isHidden ? 'block' : 'none';
        toggleButton.textContent = isHidden ? 'הסתר הסבר מעמיק' : 'הצג הסבר מעמיק';
    });

    function startSimulation() {
        simulationRunning = true;
        triggerButton.disabled = true;
        wavesInfo.textContent = 'רעידת אדמה החלה... גלי גוף מתפשטים...';
        waveTimer = 0;
        waveEffectStartTimes = {}; // Reset arrival times
        waveEffectDurations = {};

        // Reset building positions and styles
        buildings.forEach(b => {
            b.style.transform = 'translateY(0px) translateX(0px) rotate(0deg)';
            b.style.opacity = 1; // Ensure buildings are visible
             b.style.boxShadow = '2px 2px 5px rgba(0,0,0,0.2)'; // Reset shadow
        });

        // Calculate effect start times at each building's horizontal position
        // Surface waves propagate along the surface from the epicenter projection.
        const epicenterSurfaceX = hypocenterX; // X coordinate of epicenter projection on surface

        buildings.forEach((building, index) => {
            const buildingRect = building.getBoundingClientRect();
            // Get building's center X relative to simulation area's left edge
            const buildingX = (buildingRect.left + buildingRect.width / 2) - simulationArea.getBoundingClientRect().left;
            const distanceToEpicenterProjection = Math.abs(buildingX - epicenterSurfaceX);

            // The time at which Love and Rayleigh wave *effect starts* at this building location,
            // based on them propagating along the surface from the epicenter projection,
            // *after* the initial body waves have reached the surface.
            const baseSurfaceWaveStartTime = waveSpeeds.bodyWaveReachSurfaceTime; // Delay for body waves to reach surface
            const propagationDelayLove = distanceToEpicenterProjection / waveSpeeds.Love;
            const propagationDelayRayleigh = distanceToEpicenterProjection / waveSpeeds.Rayleigh;


            waveEffectStartTimes[index] = {
                Love: baseSurfaceWaveStartTime + propagationDelayLove,
                Rayleigh: baseSurfaceWaveStartTime + propagationDelayRayleigh
            };

            // Define how long the effect lasts *at this point* - could be constant or vary
             waveEffectDurations[index] = {
                 Love: 200, // Duration for Love wave effect
                 Rayleigh: 250 // Duration for Rayleigh wave effect (typically longer)
             };
        });

        requestAnimationFrame(updateSimulation);
    }

    function updateSimulation() {
        if (!simulationRunning) return;

        waveTimer++;

        const bodyWavePhaseEnd = waveSpeeds.bodyWaveReachSurfaceTime; // When surface waves *start* propagating

        let currentWaveType = 'גלי גוף (P ו-S) מתפשטים מהמוקד...'; // Default state

        if (waveTimer >= bodyWavePhaseEnd) {
             // Check if any surface wave effect is currently active on any building
             let surfaceWaveActive = false;
             let loveActive = false;
             let rayleighActive = false;

             buildings.forEach((building, index) => {
                 const arrival = waveEffectStartTimes[index];
                 const duration = waveEffectDurations[index];
                 const bTime = waveTimer;

                 // Track if effects are active for this building
                 const isLoveActive = bTime >= arrival.Love && bTime < arrival.Love + duration.Love;
                 const isRayleighActive = bTime >= arrival.Rayleigh && bTime < arrival.Rayleigh + duration.Rayleigh;

                 if (isLoveActive || isRayleighActive) {
                     surfaceWaveActive = true;
                     if (isLoveActive) loveActive = true;
                     if (isRayleighActive) rayleighActive = true;
                 }

                 let totalDisplacementX = 0;
                 let totalDisplacementY = 0; // Vertical displacement (Rayleigh)
                 let totalRotation = 0; // Rotation (Rayleigh)

                 // Apply Love wave effect
                 if (isLoveActive) {
                     const timeSinceArrival = bTime - arrival.Love;
                     // Simulate oscillation with amplitude decay
                     const amplitudeDecay = Math.max(0, 1 - timeSinceArrival / duration.Love);
                     const phase = timeSinceArrival / 15; // Oscillation speed (tuned)

                     totalDisplacementX += Math.sin(phase * Math.PI * 2) * 25 * amplitudeDecay; // Max 25px horizontal shear
                 }

                 // Apply Rayleigh wave effect
                 if (isRayleighActive) {
                    const timeSinceArrival = bTime - arrival.Rayleigh;
                     // Simulate oscillation with amplitude decay
                    const amplitudeDecay = Math.max(0, 1 - timeSinceArrival / duration.Rayleigh);
                    const phase = timeSinceArrival / 10; // Oscillation speed (slower than Love for visual distinction)

                    const rayleighAmplitude = 35 * amplitudeDecay; // Max 35px combined amplitude (larger than Love)
                    // Elliptical motion approximation: Combine horizontal and vertical sine/cosine waves
                    // Note: Rayleigh motion is typically retrograde elliptical (backward roll)
                    // A simplified approximation using phase offset:
                    totalDisplacementX += Math.cos(phase * Math.PI * 2) * rayleighAmplitude * 0.6; // Horizontal component
                    totalDisplacementY += Math.sin(phase * Math.PI * 2 + Math.PI / 2) * rayleighAmplitude * 1.0; // Vertical component (larger, 90 deg phase shift)

                    // Add significant rotation linked to the horizontal movement for leaning/rocking
                    totalRotation += Math.cos(phase * Math.PI * 2) * 12 * amplitudeDecay; // Max 12 degrees rotation
                }

                 // Apply the combined transform
                 // translateY is negative because CSS transform Y is positive downwards
                 // Keep buildings anchored to the ground's Y=0 line conceptually
                 building.style.transform = `translateX(${totalDisplacementX}px) translateY(${-totalDisplacementY}px) rotate(${totalRotation}deg)`;

                 // Optional: Visual cue for stress/damage based on displacement/rotation
                 const stressLevel = Math.max(Math.abs(totalDisplacementX), Math.abs(totalDisplacementY), Math.abs(totalRotation * 2)); // Simple metric
                 const maxStress = 30; // Threshold for max visual stress
                 const opacity = Math.max(0.2, 1 - (stressLevel / maxStress) * 0.5); // Fade slightly at high stress
                 building.style.opacity = opacity;

                 // More dramatic effect: Shake the entire ground element slightly with Rayleigh waves
                 // This is a simplification, Rayleigh waves affect the surface layer.
                 if (isRayleighActive && index === 0) { // Apply ground shake based on the first building's movement
                     // ground.style.transform = `translateX(${totalDisplacementX * 0.1}px) translateY(${-totalDisplacementY * 0.1}px)`; // Subtle ground shake
                 } else if (index === 0) {
                      // ground.style.transform = 'none'; // Reset ground transform
                 }

             });

             if (loveActive && rayleighActive) {
                 currentWaveType = 'גלי שטח: אהבה (צידי) וריילי (מתגלגל)';
             } else if (loveActive) {
                 currentWaveType = 'גלי שטח: אהבה (תנועה צידית חזקה)';
             } else if (rayleighActive) {
                  currentWaveType = 'גלי שטח: ריילי (תנועה אליפטית והרסנית)';
             } else if (surfaceWaveActive) {
                  currentWaveType = 'גלי שטח מתפשטים...'; // General state if waves are somewhere but not strongly hitting buildings
             } else {
                 // All surface effects might have finished for all buildings
                 // Need a check to see if we are *past* the time any effect could be active
                 let maxEffectEndTime = 0;
                 for(const idx in waveEffectStartTimes) {
                     maxEffectEndTime = Math.max(maxEffectEndTime, waveEffectStartTimes[idx].Rayleigh + waveEffectDurations[idx].Rayleigh);
                 }

                 if (waveTimer > maxEffectEndTime) {
                    simulationRunning = false;
                    triggerButton.disabled = false;
                    wavesInfo.textContent = 'סימולציה הסתיימה. גלי שטח גרמו לתנועה הגדולה ביותר.';
                     // Reset buildings to original position after sim ends with a slight delay/transition
                    buildings.forEach(b => {
                         b.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                         b.style.transform = 'translateY(0px) translateX(0px) rotate(0deg)';
                         b.style.opacity = 1;
                         b.style.boxShadow = '2px 2px 5px rgba(0,0,0,0.2)';
                         // Remove transition after it finishes so next quake is responsive
                         b.addEventListener('transitionend', function handler() {
                              b.style.transition = 'transform 0.05s linear';
                              b.removeEventListener('transitionend', handler);
                         });
                     });
                     return; // Stop the animation loop
                 } else {
                      currentWaveType = 'השפעת הגלים דועכת...'; // Between wave passing and full reset
                 }
             }
        }

        wavesInfo.textContent = `זמן: ${Math.max(0, waveTimer)} | ${currentWaveType}`;


        requestAnimationFrame(updateSimulation);
    }

</script>
```